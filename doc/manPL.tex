% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T2A]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{ The \textsf{PL} package \mbox{}}}\\
\vfill

\hypersetup{pdftitle= The \textsf{PL} package }
\markright{\scriptsize \mbox{}\hfill  The \textsf{PL} package  \hfill\mbox{}}
{\Huge  Version 2.6.0 \mbox{}}\\[1cm]
{February, 2015\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Igor G. Korepanov \mbox{}}}\\
{\Large \textbf{ Alex I. Korepanov \mbox{}}}\\
{\Large \textbf{ Nurlan M. Sadikov \mbox{}}}\\
\hypersetup{pdfauthor= Igor G. Korepanov ;  Alex I. Korepanov ;  Nurlan M. Sadikov }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Nurlan M. Sadikov }  Email: \href{mailto://ancleCharly@gmail.com} {\texttt{ancleCharly@gmail.com}}}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
\index{License} {\copyright} 2000-2014 by Igor G. Korepanov, Nurlan M. Sadykov and Alex I.
Korepanov 

 UNKNOWNEntity(PL) is free sotware; you car redistribute it and/or modify it
under the terms of the \href{ http://www.fsf.org/licenses/gpl.html } {GNU General Public License} as published by Free Software Foundation; either version 2 of the License, or
(at any your options) any later version. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Содержание\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Шаровые
комплексы.}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X83577E337970576A}{}
{
 Piecewise-linear, or simply PL, ball complexes are, at least at this moment,
the central objects with which our package $PL$ deals. First, a ball complex is, simply speaking, a kind of cell complex but
such where all \emph{closed} cells ( = balls) are \emph{embedded}. In particular, their boundaries are genuine spheres, not crumpled/folded.
The formal definition of $PL$ ball complex reads: A PL ball complex is a pair $(X, U)$, where $X$ is a compact Euclidean polyhedron and $U$ is a covering of $X$ by closed PL-balls such that the following axioms are satisfied: 
\begin{itemize}
\item  the relative interiors of balls from $U$ form a partition of $X$, 
\item  the boundary of each ball from $U$ is a union of balls from $U$.
\end{itemize}
 We also call PL ball complexes ``polytopes'', for brevity, hence prefix
``Pol'' in the names of some of our functions. 
\section{\textcolor{Chapter }{Representation of a PL ball complex}}\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X7A57CB8E853465BB}{}
{
 A $PL$-ball complex is defined up to $PL$-homeomorphism only by the combinatorics of adjunctions of its balls. Due to
this, we represent them combinatorially in the following way. First, we assume
that all vertices in the complex are numbered from 1 to their total number $N_0$. Hence, in this sense, the 0-skeleton of the complex is described. Next,
assuming that the $k$-skeleton is already given, which implies (in particular) the numeration of
all $k$-cells, we describe the $(k+1)$-skeleton as the list of all $(k+1)$-cells, each of which, in its turn, is the set of numbers of $k$-cells in its boundary. Then we compose the list of length $n$, where $n$ is the dimension of the complex, whose elements are lists of 1-,..., $n$-cells. Thus, a three-dimensional ball $B^3$ can be represented by the following $PL$ ball complex with two vertices 1 and 2: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  [
    [ [1,2], [1,2] ], # two one-dimensional simplexes, each with
                      # ends 1 and 2, of which the first is referred to
                      # in the next line as 1, the second - as 2;
    [ [1,2], [1,2] ], # two disks - bigons - bounded each by
                      # one-dimensional simplexes 1 and 2;
    [ [1,2] ]         # the three-ball bounded by bigons 1 and 2
  ]
  			
\end{Verbatim}
 ТУТ БЫ
НАДО
ВСТАВИТЬ
КАРТИНКУ
Actually, we add a list of vertices with their names or something like that in
the beginning of the above ball complex representation. For instance, our
function \texttt{ballAB}$(n)$ calls them \texttt{"A"} and \texttt{"B"}. So, our \textsf{GAP} representation of the ball in
Figure\texttt{\symbol{126}}\texttt{\symbol{92}}ref\texttt{\symbol{123}}fig:B3\texttt{\symbol{125}}
is the following record: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@ballAB(3);  |
  rec( vertices := [ "A", "B" ], 
    faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ] ] ] 
   )
  			
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsPolytope}}
\logpage{[ 1, 1, 1 ]}\nobreak
\hyperdef{L}{X81EA74AA7B4B6DDB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPolytope({\mdseries\slshape pol})\index{IsPolytope@\texttt{IsPolytope}}
\label{IsPolytope}
}\hfill{\scriptsize (функция)}}\\


 Функция
проверяет
формальные
признаки
структуры $pol$ в
соответствии
с
правилами
задания
политопов.
Если
данные
построены
корректным
образом,
то
функция
выдаст $true$ и $false$ в
противном
случае. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@IsPolytope(T2);|
  true
  				
\end{Verbatim}
 Так
как
нет
единого
алгоритма
распознавания $n-$мерной
сферы,
проверка
того,
что
каждая
клетка
является
шаром
опушена.
Это
может
породить
ошибку
когда
данные
удовлетворяют
всем
формальным
признакам,
но
политоп
не
является
шаровым.
В
данном
случае
программа,
все
равно
выдаст $true$ вместо
положенного $false.$ }

 }

 
\section{\textcolor{Chapter }{Указывающие
функции}}\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X8663A2DA7C5D0144}{}
{
 В
данном
разделе
представлены
функции
которые
могут
либо
распознать
многообразие
по
политопу,
либо
вычислить
инвариант
этого
многообразия. 

\subsection{\textcolor{Chapter }{EulerNumber}}
\logpage{[ 1, 2, 1 ]}\nobreak
\hyperdef{L}{X7F2B23508384AD56}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EulerNumber({\mdseries\slshape pol})\index{EulerNumber@\texttt{EulerNumber}}
\label{EulerNumber}
}\hfill{\scriptsize (функция)}}\\


 функция
вычисляет
число
Эйлера
для
шарового
комплекса.
Данная
функция
полиморфна
и
способна
принимать
для
вычислений
данные
типа
политоп
(IsPolytope),
именнованные
списки
по
размерностям
в
котором
содержится
структура
политопа
и
именованный
список
по
размерностям
элементами
которого
могут
выступать
количества
клеток
определенной
размерности. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@EulerNumber(T2);|
  0
  !gapprompt@gap>| !gapinput@EulerNumber(sphereAB(4));|
  2
  !gapprompt@gap>| !gapinput@EulerNumber(sphereAB(3));|
  0
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{FundGroup}}
\logpage{[ 1, 2, 2 ]}\nobreak
\hyperdef{L}{X7E2C717A7CE81114}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FundGroup({\mdseries\slshape pol})\index{FundGroup@\texttt{FundGroup}}
\label{FundGroup}
}\hfill{\scriptsize (функция)}}\\


 Computes the fundamental group of the given polytope. }

 }

 
\section{\textcolor{Chapter }{Общая
информация
о
шаровом
комплексе}}\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X7C31865383DD667E}{}
{
 

\subsection{\textcolor{Chapter }{LengthPol}}
\logpage{[ 1, 3, 1 ]}\nobreak
\hyperdef{L}{X82674C6C7C537F9E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LengthPol({\mdseries\slshape pol})\index{LengthPol@\texttt{LengthPol}}
\label{LengthPol}
}\hfill{\scriptsize (функция)}}\\


 В $resul.d$ указывается
мощьность $d$-мерного
остова
в
политопе $pol.$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@LengthPol(T2);|
  total16
  rec( 0 := 4, 1 := 8, 2 := 4 )
  					  	
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PolBoundary}}
\logpage{[ 1, 3, 2 ]}\nobreak
\hyperdef{L}{X7826D40B82C44A08}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolBoundary({\mdseries\slshape pol})\index{PolBoundary@\texttt{PolBoundary}}
\label{PolBoundary}
}\hfill{\scriptsize (функция)}}\\


 вычисляет
границу
политопа.
На
выход
подает
список
в
котором
указаны
только
клетки
размерности $(n-1)$ составляющие
границу. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@PolBoundary(T2);|
  [ ]
  !gapprompt@gap>| !gapinput@s1:=sphereAB(1);;|
  !gapprompt@gap>| !gapinput@d2:=ballAB(2);;|
  !gapprompt@gap>| !gapinput@ft2:=PolProduct(d2,s1);;|
  !gapprompt@gap>| !gapinput@PolBoundary(ft2);|
  [ 1, 2, 3, 4 ]
  						
\end{Verbatim}
 В
данном
примере $T2$ является
тором, $s1$ -
одномерная
сфера, $d2$ -
двумерный
диск и $ft2$ -
полноторие
созданное
как
декартово
произведение
2-диска
и
1-сферы. }

 

\subsection{\textcolor{Chapter }{PolInnerFaces}}
\logpage{[ 1, 3, 3 ]}\nobreak
\hyperdef{L}{X7DF0C625871788B7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolInnerFaces({\mdseries\slshape pol})\index{PolInnerFaces@\texttt{PolInnerFaces}}
\label{PolInnerFaces}
}\hfill{\scriptsize (функция)}}\\


 Build index of inner faces of given polytope complex $returned[i]$ - set of inner faces of dimensions (i-1). Any face is outer if it has at most
1 adjacent face of higher dimension of if it lies in the boundary of such a
face. And inner faces are not outer faces. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@PolInnerFaces(T2);|
  [ [ 1 .. 4 ], [ 1 .. 8 ] ]
  !gapprompt@gap>| !gapinput@PolInnerFaces(ft2);|
  [ [  ], [  ], [ 5, 6 ] ]
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{MaxTree}}
\logpage{[ 1, 3, 4 ]}\nobreak
\hyperdef{L}{X7DDF02FE8581EF3D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MaxTree({\mdseries\slshape pol})\index{MaxTree@\texttt{MaxTree}}
\label{MaxTree}
}\hfill{\scriptsize (функция)}}\\


 finds a maximal tree in the 1-skeleton of a polytope as a list of edges. }

 Пусть
клетки $a$ и $b$ имеют
размерности $n$ и $n-1$ соответственно
и
клетка $b$ содержится
в
клетке $a,$ то
есть $b \subset a.$ Назовем
ориентацию
клетки
которую
клетка $b$ наследует
с
клетки $a$ индуцированной
(обозначение $\epsilon(b|a)$) если
она
удовлетворяет
условию $\epsilon(b_1|a)\epsilon(c|b_1) = -\epsilon(b_2|a)\epsilon(c|b_2),$ где
клетка $c$ имеет
размерность $n-2$ и $c = b_1 \cap b_2.$ Считаем,
что на
ребре
в
вершине
с
меньшим
индексом
индуцироуется
отрицательная
ориентация,
на
ребре
с
большим
индексом
--
положительная. 

\subsection{\textcolor{Chapter }{CellOrient}}
\logpage{[ 1, 3, 5 ]}\nobreak
\hyperdef{L}{X82CF2896859B26C6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CellOrient({\mdseries\slshape pol})\index{CellOrient@\texttt{CellOrient}}
\label{CellOrient}
}\hfill{\scriptsize (функция)}}\\


 Вычисляются
индуцированные
ориентации
для
клеток.
Provides inductively some orientations for cells of dimensions $1..n=dim(pol)$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@dd;|
  rec(
    faces := [ [ [ 1, 3 ], [ 2, 3 ], [ 2, 4 ], [ 1, 4 ] ], [ [ 1, 2, 3, 4 ] ] ],
    vertices := [ 1 .. 4 ] )
  !gapprompt@gap>| !gapinput@CellOrient(dd);|
  [ [ [ -1, 1 ], [ -1, 1 ], [ -1, 1 ], [ -1, 1 ] ], [ [ -1, 1, -1, 1 ] ] ]
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PolOrient}}
\logpage{[ 1, 3, 6 ]}\nobreak
\hyperdef{L}{X7A1EAA26847A1C43}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolOrient({\mdseries\slshape pol})\index{PolOrient@\texttt{PolOrient}}
\label{PolOrient}
}\hfill{\scriptsize (функция)}}\\


 If $pol$ is orientable, gives a consistent orientation of $n-$faces ($n=dim(pol)$), otherwise returns $fail.$ Причем,
ориентации
клеток
находятся
в
следующем
отношении $\epsilon(b|a_1)\epsilon(a_1) = -\epsilon(b|a_2)\epsilon(a_2)$ }

 

\subsection{\textcolor{Chapter }{OrientTriangulated}}
\logpage{[ 1, 3, 7 ]}\nobreak
\hyperdef{L}{X81AE197083B0A56A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OrientTriangulated({\mdseries\slshape pol})\index{OrientTriangulated@\texttt{OrientTriangulated}}
\label{OrientTriangulated}
}\hfill{\scriptsize (функция)}}\\


 Function computes consistent orientation on simpleces of greatest dimension on
a given triangulated complex $pol.$ Returns array of -1, 1-s which correspond to the orientation of simplices of
greatest dimension of $pol.$ }

 

\subsection{\textcolor{Chapter }{dataPachner}}
\logpage{[ 1, 3, 8 ]}\nobreak
\hyperdef{L}{X83986ED47DDF8E20}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{dataPachner({\mdseries\slshape dim, k})\index{dataPachner@\texttt{dataPachner}}
\label{dataPachner}
}\hfill{\scriptsize (функция)}}\\


 Выводит
информацию
о
указанном
движении
Пахнера
размерности $dim$, один
из
кластеров
которого
содержит $k$ -
симплексов,
все
информация
принадлежащая
данному
кластеру
условно
обозначена
буквой $l$ (left).
Второй
кластер
симплексов
получающийся
при
преобразованиях
Пахнера
обозначен
буквой $r$ (right). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@Print(dataPachner(3,2));|
  rec(
    l := rec(
        pol := rec(
            faces :=
             [
                [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ],
                    [ 1, 5 ], [ 2, 5 ], [ 3, 5 ] ],
                [ [ 1, 4, 5 ], [ 1, 7, 8 ], [ 2, 4, 6 ], [ 2, 7, 9 ],
                    [ 3, 5, 6 ], [ 3, 8, 9 ], [ 1, 2, 3 ] ],
                [ [ 1, 3, 5, 7 ], [ 2, 4, 6, 7 ] ] ],
            vertices := [ 1, 2, 3, 4, 5 ] ),
        sim := [ [ 1, 2, 3, 4 ], [ 1, 2, 3, 5 ] ],
        vnut := [ 7 ] ),
    r := rec(
        pol := rec(
            faces :=
             [
                [ [ 1, 2 ], [ 1, 4 ], [ 2, 4 ], [ 1, 5 ], [ 2, 5 ], [ 4, 5 ],
                    [ 1, 3 ], [ 3, 4 ], [ 3, 5 ], [ 2, 3 ] ],
                [ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 2, 7, 8 ], [ 4, 7, 9 ],
                    [ 3, 8, 10 ], [ 5, 9, 10 ], [ 2, 4, 6 ], [ 3, 5, 6 ],
                    [ 6, 8, 9 ] ],
                [ [ 1, 2, 7, 8 ], [ 3, 4, 7, 9 ], [ 5, 6, 8, 9 ] ] ],
            vertices := [ 1, 2, 3, 4, 5 ] ),
        sim := [ [ 1, 2, 4, 5 ], [ 1, 3, 4, 5 ], [ 2, 3, 4, 5 ] ],
        vnut := [ 7, 8, 9 ] ) )
    						
\end{Verbatim}
 В
каждой
из
этих
двух
записей $.l$ или $.r$ содержатся
структуры $.pol$ -
задание
кластера
в виде
шарового
комплекса, $.sim$ -
представление
кластера
в виде
симплексов,
то
есть
задание
симплексов
через
набор
вершин
на
которые
они
натянуты
и $.vnut$ список
внутренних $(n-1)-$мерных
клеток
шарового
комплекса. }

 Симплициальный
комплекс
может
быть
задан
как
набор
симплексов,
каждый
из
которых
представлен
списком
вершин
на
которые
он
натянут.
При
задании
симплициальных
многообразий
достаточно
указать
симплексы
размерности $n.$ При
этом
существенным
условием
является
то, что
все
симплексы
должны
быть
натянуты
на
различные
наборы
вершин.
Например
граница
четырехмерного
симплекса
может
быть
представлена
как 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@sim:=[ [ 1, 2, 3, 4 ], [ 1, 2, 3, 5 ], [ 1, 2, 4, 5 ],|
  				[ 1, 3, 4, 5 ], [ 2, 3, 4, 5 ] ];
  				
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{FromSimplexToPolytope}}
\logpage{[ 1, 3, 9 ]}\nobreak
\hyperdef{L}{X873915C482448F75}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FromSimplexToPolytope({\mdseries\slshape simplex})\index{FromSimplexToPolytope@\texttt{FromSimplexToPolytope}}
\label{FromSimplexToPolytope}
}\hfill{\scriptsize (функция)}}\\


 преобразует
список
симплексов
в
шаровой
комплекс. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@FromSimplexToPolytope(sim);|
  rec(
    faces :=
      [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ], [ 1, 5 ],
            [ 2, 5 ], [ 3, 5 ], [ 4, 5 ] ],
        [ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 2, 4, 6 ], [ 3, 5, 6 ], [ 1, 7, 8 ],
            [ 2, 7, 9 ], [ 3, 8, 9 ], [ 4, 7, 10 ], [ 5, 8, 10 ], [ 6, 9, 10 ] ]
          , [ [ 1, 2, 3, 4 ], [ 1, 5, 6, 7 ], [ 2, 5, 8, 9 ], [ 3, 6, 8, 10 ],
            [ 4, 7, 9, 10 ] ] ], vertices := [ 1, 2, 3, 4, 5 ] )
  						
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Работа
с
клетками}}\logpage{[ 1, 4, 0 ]}
\hyperdef{L}{X860B263684CFACF7}{}
{
 В
данном
разделе
собраны
все
функции
позволяющие
узнать
информацию
связанную
с
какой-либо
клеткой
в
pl-разбиении
многообразия.
Клетка
в
pl-многообразии
указывается
как
пара
чисел [dim,ind],
первое
из
которых
dim есть
размерность
клетки,
второе
ind -
позиция
клетки
в
списке
pol.faces[dim].
Такую
пару в
описании
программ
мы
будет
называть
адресом
клетки
или
клеткой,
обозначение $adr.$ 

\subsection{\textcolor{Chapter }{PolBnd}}
\logpage{[ 1, 4, 1 ]}\nobreak
\hyperdef{L}{X7AB8BF4E7E72C22D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolBnd({\mdseries\slshape pol, adr})\index{PolBnd@\texttt{PolBnd}}
\label{PolBnd}
}\hfill{\scriptsize (функция)}}\\


 Creating an index of boundary faces of face $adr=[dim,ind]$ of complex $pol$. $result[i]$ - index of (i-1)-dimensional faces of $pol$ which are in the boundary of $adr$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@PolBnd(T2,[2,3]);|
  [ [ 1, 2, 3, 4 ], [ 2, 4, 5, 7 ] ]
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{FaceComp}}
\logpage{[ 1, 4, 2 ]}\nobreak
\hyperdef{L}{X7B4C20C784524379}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FaceComp({\mdseries\slshape pol, adr})\index{FaceComp@\texttt{FaceComp}}
\label{FaceComp}
}\hfill{\scriptsize (функция)}}\\


 функция
аналогичная
функции $PolBnd,$ выходные
данные
в
функции
собраны
по
размерностям.
Сама
клетка
тоже
включена
в
вывод
как
составляющая
часть
самой
себя. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@FaceComp(T2,[2,3]);|
  rec( 0 := [ 1, 2, 3, 4 ], 1 := [ 2, 4, 5, 7 ], 2 := [ 3 ] )
  						
\end{Verbatim}
 Как
видно
из
примера
каждая
именованное
поле
соответствует
некоторой
размерности. }

 

\subsection{\textcolor{Chapter }{StarFace}}
\logpage{[ 1, 4, 3 ]}\nobreak
\hyperdef{L}{X7E4697E984788243}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{StarFace({\mdseries\slshape pol, adr})\index{StarFace@\texttt{StarFace}}
\label{StarFace}
}\hfill{\scriptsize (функция)}}\\


 Вычисляет
все
клетки
которые
содержат
клетку $adr$ в
политопе $pol$.
Другими
словами
функция
вычисляет
звезду
указанной
клетки.
result.(i)
содержит
индексы $i-$клеток
входящих
в
состав
звезды. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@StarFace(T2,[0,3]);|
  rec( 1 := [ 2, 3, 6, 7 ], 2 := [ 1, 2, 3, 4 ] )
  						
\end{Verbatim}
 В
данном
примере
1-клетки
с
индексами
2, 3, 6 и 7 и
2-клетки
с
индексами
1, 2, 3 и 4
образуют
звезду
вершины
3
данного
шарового
разбиения. }

 

\subsection{\textcolor{Chapter }{PolCheckComb}}
\logpage{[ 1, 4, 4 ]}\nobreak
\hyperdef{L}{X7BBC530C857D247E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolCheckComb({\mdseries\slshape pol, adr})\index{PolCheckComb@\texttt{PolCheckComb}}
\label{PolCheckComb}
}\hfill{\scriptsize (функция)}}\\


 check if a face of given complex is combinatorial complex that is, whether
every its subface of lower dimension is uniquely determined by its vertices
(and dimension) }

 }

 
\section{\textcolor{Chapter }{Изменение $pl-$разбиения
(не
изменяющие)}}\logpage{[ 1, 5, 0 ]}
\hyperdef{L}{X81B61AF078A1C75E}{}
{
 Функции
которые
изменяют
представленное
разбиение
без
изменения
многообразия. 

\subsection{\textcolor{Chapter }{PolTriangulate}}
\logpage{[ 1, 5, 1 ]}\nobreak
\hyperdef{L}{X79EBAEC68713D5FE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolTriangulate({\mdseries\slshape pol})\index{PolTriangulate@\texttt{PolTriangulate}}
\label{PolTriangulate}
}\hfill{\scriptsize (функция)}}\\


 функция
создает
триангуляцию
политопа $pol$.
Заметим,
что
политоп
после
триангуляции
может
остаться
не
комбинаторным. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@PolTriangulate(sphereAB(2));|
  rec(
    faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ] ],
        [ [ 1, 3, 4 ], [ 2, 3, 4 ], [ 1, 5, 6 ], [ 2, 5, 6 ] ] ],
    vertices := [ "A", "B", "V1", "V2" ] )
  						
\end{Verbatim}
 Triangulating a polytope. }

 

\subsection{\textcolor{Chapter }{FirstBoundary}}
\logpage{[ 1, 5, 2 ]}\nobreak
\hyperdef{L}{X7DE97F0184E8F0BE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FirstBoundary({\mdseries\slshape pol})\index{FirstBoundary@\texttt{FirstBoundary}}
\label{FirstBoundary}
}\hfill{\scriptsize (функция)}}\\


 данная
функция
создает
такое
упорядочение
клеток
политопа,
что
клетки
лежащие
на
границе
имеют
наименьшие
индексы
в
списках
pol.faces[dim].
Внутренний
порядок
клеток
на
границе
остается
неизменным
(имеется
в виду
порядок
клеток
созданный
индексацией
внутри
политопа). }

 

\subsection{\textcolor{Chapter }{PermFaces}}
\logpage{[ 1, 5, 3 ]}\nobreak
\hyperdef{L}{X863CAD14822179DC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PermFaces({\mdseries\slshape pol, perm, dim})\index{PermFaces@\texttt{PermFaces}}
\label{PermFaces}
}\hfill{\scriptsize (функция)}}\\


 производит
переупорядочение
клеток
размерности $dim$ в
политопе $pol$ по
перестановке $perm.$ }

 Клетку
размерности $d$ в
шаровом
комплексе
называем
минимальной,
если
ее
граница
содержит
только
две
клетки
размерности $(d - 1)$ 

\subsection{\textcolor{Chapter }{ContractMiniFace}}
\logpage{[ 1, 5, 4 ]}\nobreak
\hyperdef{L}{X844FBAF17BC1B42B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ContractMiniFace({\mdseries\slshape pol, adr})\index{ContractMiniFace@\texttt{ContractMiniFace}}
\label{ContractMiniFace}
}\hfill{\scriptsize (функция)}}\\


 В
политопе $pol$ стягивается
минимальная
клетка $adr.$ Образом
стягивания
при
этом
является
граничная
клетка
с
меньшим
индексом. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@s1:=sphereTriangul(1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ] ], vertices := [ 1 .. 3 ] )
  !gapprompt@gap>| !gapinput@s1:=ContractMiniFace(s1,[1,1]);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ 1, 3 ] )
  						
\end{Verbatim}
 В
некоторых
случаях
стягивание
минимальной
клетки
невозможно,
так
как
данные
которые
мы
получим
после
стягивания
могут
не
оказаться $pl-$комплексом.
Программа
проведет
стягивание
минимальной
клетки
в
любом
случае,
даже
если
применение
функции
выведет
нас из
категории
шаровых
комплексов.
По
этому,
применение
этой
функции
требует
доказательства
того,
что
после
стягивание
не
нарушится
условие,
что
все
клетки
получившегося
комплекса
шары.
Например,
если в
примере
описанном
выше
попробовать
стянуть
в
окружности $s1$ ребро,
то
получим
следующее 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@s1:=ContractMiniFace(s1,[1,1]);|
  rec( faces := [ [ [ 1 ] ] ], vertices := [ 1 ] )
  !gapprompt@gap>| !gapinput@IsPolytope(s1);|
  false
  						
\end{Verbatim}
 Как
видим
выходные
данные
не
являются
политопом.
По
этому
проверка
допустимости
данной
операции
остается
за
пользователем. }

 

\subsection{\textcolor{Chapter }{DivideFace}}
\logpage{[ 1, 5, 5 ]}\nobreak
\hyperdef{L}{X7AF2A3E286F2E10F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivideFace({\mdseries\slshape pol, adr, set})\index{DivideFace@\texttt{DivideFace}}
\label{DivideFace}
}\hfill{\scriptsize (функция)}}\\


 Пусть
имеется
клетка
с
адресом $adr$ размерности $d=adr[1]$ и
клетки $set$ лежащие
на
границе
клетки $adr$ образуют $(d-2)-$мерную
сферу $S^{d-2}$, тогда
клетку $adr$ можно
разбить
на две
части
натянув
на
сферу $S^{d-2}$ диск $D^{d-1}$ внутри
клетки $adr$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@octahedron;|
  rec(
    faces :=
  	[ [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 1, 4 ], [ 1, 5 ], [ 2, 5 ], [ 3, 5 ], 
    		[ 4, 5 ], [ 1, 6 ], [ 2, 6 ], [ 3, 6 ], [ 4, 6 ] ],
  	  [ [ 1, 5, 6 ], [ 2, 6, 7 ], [ 3, 7, 8 ], [ 4, 5, 8 ], [ 1, 9, 10 ],
  	  	[ 2, 10, 11 ], [ 3, 11, 12 ], [ 4, 9, 12 ] ], [ [ 1 .. 8 ] ] ], 
  	vertices := [ 1 .. 6 ] )
  !gapprompt@gap>| !gapinput@DivideFace(octahedron,[3,1],[1,2,3,4]);|
  rec(
    faces :=
   	[ [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 1, 4 ], [ 1, 5 ], [ 2, 5 ], [ 3, 5 ],
    		[ 4, 5 ], [ 1, 6 ], [ 2, 6 ], [ 3, 6 ], [ 4, 6 ] ],
  	  [ [ 1, 5, 6 ], [ 2, 6, 7 ], [ 3, 7, 8 ], [ 4, 5, 8 ], [ 1, 9, 10 ], 
  	    [ 2, 10, 11 ], [ 3, 11, 12 ], [ 4, 9, 12 ], [ 1, 2, 3, 4 ] ],
  	  [ [ 1, 4, 2, 3, 9 ], [ 5, 6, 7, 8, 9 ] ] ], 
  		vertices := [ 1 .. 6 ] )
  						
\end{Verbatim}
 В
случае
когда
разбивается
одномерная
клетка,
указанная
клетка
дробится
на две
части
новой
вершиной,
вместо
множества $set$ указывается
имя
новой
вершины
разбиения. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@s1:=sphereAB(1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ "A", "B" ] )
  !gapprompt@gap>| !gapinput@DivideFace(s1,[1,1],3);|
  rec( faces := [ [ [ 1, 3 ], [ 1, 2 ], [ 2, 3 ] ] ], vertices := [ "A", "B", 3 ] )
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{UnionFace}}
\logpage{[ 1, 5, 6 ]}\nobreak
\hyperdef{L}{X8508B54A7A8AC6CB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnionFace({\mdseries\slshape pol, kl1, kl2})\index{UnionFace@\texttt{UnionFace}}
\label{UnionFace}
}\hfill{\scriptsize (функция)}}\\


 На
вход
функции
посылаются
две
клетки
одной
и той
же
размерности
для
объединения
их в
одну
клетку.
По
сути
данной
функцией
реализуется
обратная
операция
к
функции $DivideFace$ разбивающей
клетку
на две
части. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@UnionFace(p3,[3,1],[3,2]);|
  rec(
    faces :=
      [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ], [ 1, 5 ],
            [ 2, 5 ], [ 3, 5 ], [ 4, 5 ] ],
        [ [ 2, 4, 6 ], [ 2, 7, 9 ], [ 4, 7, 10 ], [ 3, 5, 6 ], [ 3, 8, 9 ],
            [ 5, 8, 10 ], [ 1, 4, 5 ], [ 1, 7, 8 ] ],
        [ [ 1, 2, 4, 5, 7, 8 ], [ 3, 6, 7, 8 ] ] ],
    vertices := [ 1, 2, 3, 4, 5 ] )
  						
\end{Verbatim}
 Объединение
двух
клеток $D^k_1$ и $D^k_2$ в одну
в
политопе $pol$ можно
провести
только
в том
случае
если
звезда
пересечения
этих
клеток
состоит
только
из $D^k_1$ и $D^k_2$. Для
проведения
объединения
функция
проверяет,
что
данные
клетки
пересекаются
по
одному
диску.
Если
после
объединения
указанных
клеток
комплекс
перестанет
быть
шаровым
разбиением,
то
функция
не
будет
проводить
объединение,
на
выход
будет
подан
начальный
политоп
и
информационная
строка
с
пояснением
почему
функция
отказывается
работать. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@UnionFace(T2,[2,1],[2,3]);;|
  This faces intersected on some balls or not intersected.
  I cannot union the faces in a polytope.
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PolSimplify}}
\logpage{[ 1, 5, 7 ]}\nobreak
\hyperdef{L}{X784F04327D5BD9A8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolSimplify({\mdseries\slshape pol})\index{PolSimplify@\texttt{PolSimplify}}
\label{PolSimplify}
}\hfill{\scriptsize (функция)}}\\


 Проводит
упрощение
политопа $pol$ фукцией
UnionFaces.
Данная
функция
перебирает
все
возможности
начиная
с
клеток
максимальной
размерности.
Вновь
появившиеся
возможности
функция
не
исследует.
По
этому
функцию
можно
запускать
несколько
раз
если
целью
стоит
максимально
упростить
политоп. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@a:=ballTriangul(3);;|
  !gapprompt@gap>| !gapinput@PolSimplify(a);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ] ]
       ], vertices := [ 1, 2 ] )
  						
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Непосредственное
создание
политопов}}\logpage{[ 1, 6, 0 ]}
\hyperdef{L}{X7A0D373E78BB66A0}{}
{
 Для
создания $n-$мерного
диска
и
сферы
имеются
стандартные
функции
включенные
в
библиотеку 

\subsection{\textcolor{Chapter }{ballAB}}
\logpage{[ 1, 6, 1 ]}\nobreak
\hyperdef{L}{X83EC07DE83EC07DE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ballAB({\mdseries\slshape dim})\index{ballAB@\texttt{ballAB}}
\label{ballAB}
}\hfill{\scriptsize (функция)}}\\


 Создает
минимально
возможное
шаровое
разбиение
диска
размерности $dim.$ }

 

\subsection{\textcolor{Chapter }{sphereAB}}
\logpage{[ 1, 6, 2 ]}\nobreak
\hyperdef{L}{X791C9DFE87250DEF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{sphereAB({\mdseries\slshape dim})\index{sphereAB@\texttt{sphereAB}}
\label{sphereAB}
}\hfill{\scriptsize (функция)}}\\


 Создает
минимально
возможное
pl-разбиение
сферы
размерности $dim.$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@sphereAB(3);|
  rec(
    faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ],
        [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ "A", "B" ] )
  						
\end{Verbatim}
 }

 В
библиотеку
так же
включена
функция
создающая
задание
диска
и
сферы
в виде
триангулированных
шаровых
комплексов 

\subsection{\textcolor{Chapter }{ballTriangul}}
\logpage{[ 1, 6, 3 ]}\nobreak
\hyperdef{L}{X82DB526A7F364516}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ballTriangul({\mdseries\slshape dim})\index{ballTriangul@\texttt{ballTriangul}}
\label{ballTriangul}
}\hfill{\scriptsize (функция)}}\\


 Создает
симплекс
размерности $dim$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@ballTriangul(2);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ], [ [ 1 .. 3 ] ] ],
    vertices := [ 1 .. 3 ] )
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{sphereTriangul}}
\logpage{[ 1, 6, 4 ]}\nobreak
\hyperdef{L}{X80EEACD2781E40F7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{sphereTriangul({\mdseries\slshape dim})\index{sphereTriangul@\texttt{sphereTriangul}}
\label{sphereTriangul}
}\hfill{\scriptsize (функция)}}\\


 Триангулированная
сфера
создается
как
граница $(dim+1)-$мерного
симплекса 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@sphereTriangul(1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ] ], vertices := [ 1 .. 3 ] )
  						
\end{Verbatim}
 }

  }

 
\section{\textcolor{Chapter }{Топологические
операции}}\logpage{[ 1, 7, 0 ]}
\hyperdef{L}{X7CC221C778D0F16A}{}
{
 

\subsection{\textcolor{Chapter }{FreeUnionPol}}
\logpage{[ 1, 7, 1 ]}\nobreak
\hyperdef{L}{X833B125E832EA5F5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FreeUnionPol({\mdseries\slshape pol1, pol2})\index{FreeUnionPol@\texttt{FreeUnionPol}}
\label{FreeUnionPol}
}\hfill{\scriptsize (функция)}}\\


 Свободное
объединение
политопов. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@FreeUnionPol(s1,s1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 3, 4 ], [ 3, 4 ] ] ],
    vertices := [ [ 1, "A" ], [ 1, "B" ], [ 2, "A" ], [ 2, "B" ] ] )
  						
\end{Verbatim}
 Объединение
происходит
путем
слияния
соответствующих
списков.
При
этом
индексы
второго
политопа
увеличиваются. }

 

\subsection{\textcolor{Chapter }{PolDoubleCone}}
\logpage{[ 1, 7, 2 ]}\nobreak
\hyperdef{L}{X813B0AA1829E736E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolDoubleCone({\mdseries\slshape pol})\index{PolDoubleCone@\texttt{PolDoubleCone}}
\label{PolDoubleCone}
}\hfill{\scriptsize (функция)}}\\


 Make a double cone with vertices V1 and V2 over the given polytope $pol.$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@PolDoubleCone(s1);|
  rec(
    faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ] ],
        [ [ 1, 3, 4 ], [ 2, 3, 4 ], [ 1, 5, 6 ], [ 2, 5, 6 ] ] ],
    vertices := [ "A", "B", "V1", "V2" ] )
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ConnectedSum}}
\logpage{[ 1, 7, 3 ]}\nobreak
\hyperdef{L}{X7F680736784EA2B0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConnectedSum({\mdseries\slshape N, M})\index{ConnectedSum@\texttt{ConnectedSum}}
\label{ConnectedSum}
}\hfill{\scriptsize (функция)}}\\


 Фукнция
создает
связную
сумму
двух
политопов $N$ и $M$ одинаковой
размерности. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@s2:=sphereAB(2);;|
  !gapprompt@gap>| !gapinput@ConnectedSum(s2,s2);|
  rec(
    faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 1, 2 ], [ 1, 2 ] ],
        [ [ 1, 3 ], [ 1, 2 ], [ 3, 4 ], [ 2, 4 ] ] ],
    vertices := [ [ 1, "A" ], [ 1, "B" ] ] )
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PolProduct}}
\logpage{[ 1, 7, 4 ]}\nobreak
\hyperdef{L}{X7A9E18837F637D8D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolProduct({\mdseries\slshape pol1, pol2})\index{PolProduct@\texttt{PolProduct}}
\label{PolProduct}
}\hfill{\scriptsize (функция)}}\\


 Функция
вычисляет
декартово
произведение
двух
шаровых
комплексов
pol1 и pol2.
Декартово
произведение
для
двух
шаровых
комплексов
определяется
как
шаровой
комплекс
составленный
из
всевозможных
шаров $D^s_i \times D^t_j$, где $D^s_i$ и $D^t_j$ клетки
комплексов $M$ и $N$,
соответственно. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@PolProduct(s1,s1);|
  rec(
    faces :=
      [ [ [ 1, 2 ], [ 1, 2 ], [ 3, 4 ], [ 3, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ],
            [ 2, 4 ] ],
        [ [ 1, 3, 5, 6 ], [ 2, 4, 5, 6 ], [ 1, 3, 7, 8 ], [ 2, 4, 7, 8 ] ] ],
    vertices := [ [ "A", "A" ], [ "A", "B" ], [ "B", "A" ], [ "B", "B" ] ] )
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ImageInPolProduct}}
\logpage{[ 1, 7, 5 ]}\nobreak
\hyperdef{L}{X7F0929CD82A0CE28}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ImageInPolProduct({\mdseries\slshape pol1, pol2, kl1xkl2})\index{ImageInPolProduct@\texttt{ImageInPolProduct}}
\label{ImageInPolProduct}
}\hfill{\scriptsize (функция)}}\\


 Вспомогательная
функция
для
декартова
произведения,
вычисляет
адрес
клетки
составленной
как
произведение
клеток $kl1$ и $kl2$ из
политопов $pol1$ и $pol2,$ соответственно.
На
вход
функции
адреса
клеток
подаются
объединенные
в
список. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@t2:=PolProduct(s1,s1);;|
  !gapprompt@gap>| !gapinput@ImageInPolProduct(s1,s1,[[1,2],[1,1]]);|
  [ 2, 3 ]
  						
\end{Verbatim}
 В
качестве
входных
данных
функции
могут
поступить
не
только
политопы
pol1 и pol2, но и
именованные
списки
по
размерностям,
каждой
размерности
k в
котором
сопоставлена
мощность
клеток
размерности
k.
Данная
возможность
позволяет
не
вычислять
эту
информацию,
при
частом
вызове
функции
для
одного
и того
же
декартова
произведения. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@ls1:=rec(0:=2, 1:=2);|
  rec( 0 := 2, 1 := 2 )
  !gapprompt@gap>| !gapinput@ImageInPolProduct(ls1,ls1,[[1,2],[1,1]]);|
  [ 2, 3 ]
  						
\end{Verbatim}
 Обратим
внимание,
что
функция
вычисляет
клетку
только
в
комплексе
составленном
функцией
PolProduct. Если
произошло
какое-либо
изменение
комплекса,
указанный
адрес
может
оказаться
не
корректным. }

 

\subsection{\textcolor{Chapter }{PreimageInPolProduct}}
\logpage{[ 1, 7, 6 ]}\nobreak
\hyperdef{L}{X7C2DFBEA78356D9D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreimageInPolProduct({\mdseries\slshape pol1, pol2, imageface})\index{PreimageInPolProduct@\texttt{PreimageInPolProduct}}
\label{PreimageInPolProduct}
}\hfill{\scriptsize (функция)}}\\


 По
заданному
образу
в
декартовом
произведении
политопов
pol1 и pol2
указываем
из
каких
клеток
была
составлена
данная
клетка
imageface. }

  

\subsection{\textcolor{Chapter }{PolProductSyms}}
\logpage{[ 1, 7, 7 ]}\nobreak
\hyperdef{L}{X7A32AE2D8733963A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolProductSyms({\mdseries\slshape })\index{PolProductSyms@\texttt{PolProductSyms}}
\label{PolProductSyms}
}\hfill{\scriptsize (функция)}}\\


 Cartesian product of two polytopes with symmetries of multipliers transferred
to it. First go the symmetries of the first multiplier, then - the second. }

 

\subsection{\textcolor{Chapter }{PolProductSymsDict}}
\logpage{[ 1, 7, 8 ]}\nobreak
\hyperdef{L}{X7B4164647D6C5EC6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolProductSymsDict({\mdseries\slshape })\index{PolProductSymsDict@\texttt{PolProductSymsDict}}
\label{PolProductSymsDict}
}\hfill{\scriptsize (функция)}}\\


 Cartesian product of two polytopes with symmetries of multipliers transferred
to it. First go the symmetries of the first multiplier, then - the second.
Also returns the face dictionary. }

 

\subsection{\textcolor{Chapter }{PolFactorInvolution}}
\logpage{[ 1, 7, 9 ]}\nobreak
\hyperdef{L}{X7A3091A38613DA64}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolFactorInvolution({\mdseries\slshape pol, invol})\index{PolFactorInvolution@\texttt{PolFactorInvolution}}
\label{PolFactorInvolution}
}\hfill{\scriptsize (функция)}}\\


 $pol$ is polytope with symmetries, $invol$ is such a list of some of its symmetries (repetitions possible) that it is
known that the product of symmetries in s is an involution returns the
factored polytope. }

 }

 
\section{\textcolor{Chapter }{Основные
принципы
перестроек
шаровых
комплексов}}\logpage{[ 1, 8, 0 ]}
\hyperdef{L}{X79A6E71D85EB8624}{}
{
 В
данном
разделе
рассказывается
об
основных
принципах
перестройки
шаровых
комплексов
связанных
с
изменением
индексации
клеток.
Изменение
индексации
клеток
является
одной
из
основных
трудностей
для
быстрого
и
удобного
построения
программ.
Во
второй
версии
пакета $PL$ мы
пользовались
следующей
идеей.
По
возможности
адреса
клеток
которые
не
участвуют
в
операции
должны
остаться
неизменными.
Тем не
менее
это не
всегда
возможно,
когда,
например,
клетка
удаляется
из
политопа.
Если
не
удается
избежать
смещение
индексов,
то по
возможности
необходимо
сделать
так,
что бы
индексы
изменились
у
минимального
количества
индексов.
Та
особенность,
что
все
построение
политопа
привязана
к
позиции
соответствующих
клеток
в
списках
pol.faces[k]
осложняет
работу
связанную
с
перестройкой
комплексов.
Начиная
с
третьей
версии
пакета $PL$ будет
организована
возможность
жесткой
индексации
клеток,
когда
позиция
клетки
в
списке
pol.faces[k]
является
одновременно
и
именем
этой
клетки.
Это,
например,
будет
означать,
что в
списках
pol.faces[k] могут
присутствовать
пустые
адреса.
На
данный
момент
присутствуют
следующие
функции
позволяющие
корректно
изменять
структуру
политопа
и
прикрепленную
к нему
информацию. 

\subsection{\textcolor{Chapter }{DelFace}}
\logpage{[ 1, 8, 1 ]}\nobreak
\hyperdef{L}{X7F4B33CD85588148}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DelFace({\mdseries\slshape pol, adr})\index{DelFace@\texttt{DelFace}}
\label{DelFace}
}\hfill{\scriptsize (функция)}}\\


 клетка $adr$ корректным
образом
исключается
из
политопа $pol.$ После
проведения
данной
операции
корректность
данных
может
быть
нарушена. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@pol:=DelFace(t2,[1,2]);;|
  !gapprompt@gap>| !gapinput@IsPolytope(pol);|
  false
  					
\end{Verbatim}
 Функция
содержит
наиболее
часто
встречающийся
код в
функциях
который
позволяет
корректно
удалить
все
упоминания
о
данной
клетке
и
подготовить
данные
для
дальнейшей
работы
алгоритма. }

 

\subsection{\textcolor{Chapter }{wasDelFace}}
\logpage{[ 1, 8, 2 ]}\nobreak
\hyperdef{L}{X8371078A7CD87B96}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{wasDelFace({\mdseries\slshape pol, adr})\index{wasDelFace@\texttt{wasDelFace}}
\label{wasDelFace}
}\hfill{\scriptsize (функция)}}\\


 Функция
корректирует
сопуствующую
информацию
прикрепленную
к
политопу $pol$ которая
должна
была
измениться
после
удаления
одной
из
клеток.
На
вход
функции
подается
политоп
и
адрес
той
клетки
которая
была
удалена.
Напомним,
что
после
удаления
клетки
индексы
больших
клеток
данной
размерности
понижаются
на
едининцу,
это
изменение
индексации
должно
быть
отображено
в той
информации
которая
сопутствует
данному
шаровому
комплексу.
Если
из
какой-либо
сопуствующей
информации
была
удалена
клетка,
то
будет
выведено
соответствующее
сообщение,
но
изменения
будут
проведены.
При
обработке
информации
по
2-узле в
политопе
будет,
в
случае
если
удаляется
2-клетка,
будет
выведено
соответствующее
сообщение,
индекс
2-клетки
будет
удален
из
списка
.2knot.sheets, если
на
данную
2-клетку
есть
ссылка
в .2knot.dpoints.(1kl), то
соответсвующая
позиция
будет
очищена. }

 Для
упрощения
перестройки
политопов
в
дальнейших
версиях
будет
поддерживаться
следующий
принцип.
Индекс $k-$клетки
в
списке $pol.faces[k]$ является
одновременно
идентификатором
клетки.
Это
позволяет
нам
создавать
такие
списки
(остовы) $pol.faces[k]$ в
которых
имеются
не
заполненые
позиции.
При
удалении
клетки
из
остова
соответствующая
позиция
в
списке $pol.faces[k]$ опустошается.
Такой
принцып
перестройки
позволит
упростить
вычисления
связанные
с
пересчетом
индексов
клеток
при
преобразованиях
политопов.
Этот
принцып
будет
поддерживаться
начиная
с
третьей
версии
пакета $PL,$ начиная
с
четвертой
версии
поддерживаться
будет
только
данный
способ
перестройки. }

 }

 
\chapter{\textcolor{Chapter }{Подполитопы,
вложения}}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7D7BDF497D34E1A0}{}
{
 Множество $subpol$ клеток
размерности $k$ будем
называть
подполитопом,
если
они
задают
некоторое
вложенное
многообразие $N \subset M.$ Самый
простой
пример
подполитопа
это
список
из
одного
элемента
любой
размерности,
который
задает
диск
внутри
политопа $pol.$ Тем не
менее
мы не
будем
создавать
какой
либо
жесткой
структуры
обозначающей
подполитоп,
так
как
его
использование
будет
ясным
из
контекста
программ. 
\section{\textcolor{Chapter }{Распознающие}}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7DEA53D985CB7916}{}
{
 

\subsection{\textcolor{Chapter }{SetOfFacesBoundary}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X846E72167C7779D2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetOfFacesBoundary({\mdseries\slshape pol, subpol, dim})\index{SetOfFacesBoundary@\texttt{SetOfFacesBoundary}}
\label{SetOfFacesBoundary}
}\hfill{\scriptsize (функция)}}\\


 Функция
выводит
границу
подполитопа $subpol$. На
выходе
будут
указаны
клетки
внутри
политопа $pol$ образующие
границу
подполитопа $subpol.$ Размерность
указанных
клеток
равняется $dim-1.$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@SetOfFacesBoundary(t2,[2,1],2);|
  [ 1, 2, 3, 4 ]
  					
\end{Verbatim}
  }

 

\subsection{\textcolor{Chapter }{SubPolytope}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X857F686C8672E246}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubPolytope({\mdseries\slshape pol, subpol, dim})\index{SubPolytope@\texttt{SubPolytope}}
\label{SubPolytope}
}\hfill{\scriptsize (функция)}}\\


 выделяем
указанный
подполитоп
как
самостоятельный.
Отношение
порядка
клеток
в
создаваемом
политопе
наследуется
из
объемлющего
политопа $pol.$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@SubPolytope(t2,[1,2],1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ],
    vertices := [ [ "A", "A" ], [ "A", "B" ] ] )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ParallelSimplify}}
\logpage{[ 2, 1, 3 ]}\nobreak
\hyperdef{L}{X83D3EDBD86CC8F58}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ParallelSimplify({\mdseries\slshape pol, subpol, dim})\index{ParallelSimplify@\texttt{ParallelSimplify}}
\label{ParallelSimplify}
}\hfill{\scriptsize (функция)}}\\


 В
политопе $pol$ производится
упрощение
с
помощью
функции
UnionFaces,
параллельно
с этим
упрощается
подполитоп $subpol$ размерности $dim.$ Информация
о
клетках
подполитопа
помещается
в
список
.subpol.
Функция
работает
только
для
подполитопов
чья
размерность
меньше
размерности
объемлющего
пространства.
Если
вложенное
подмногообразие $A$ той же
размерности,
что и
политоп $M$, можно
провести
параллельное
упрощение
c
пересечением $C = A \cap \overline{(M\A)}.$ }

 

\subsection{\textcolor{Chapter }{PolMinusFace}}
\logpage{[ 2, 1, 4 ]}\nobreak
\hyperdef{L}{X80512E7E8394ADDB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolMinusFace({\mdseries\slshape pol, adr})\index{PolMinusFace@\texttt{PolMinusFace}}
\label{PolMinusFace}
}\hfill{\scriptsize (функция)}}\\


 cuts out a neighborhood of a face with given adress from polytope.
Функция
построена
таким
образом,
что
после
вырезания
клетки
позиции
старых
клеток
в
списках
pol.faces[i] и pol.vertices не
изменяются. }

 

\subsection{\textcolor{Chapter }{PolMinusFaceDoublingMethod}}
\logpage{[ 2, 1, 5 ]}\nobreak
\hyperdef{L}{X7876CF9E8413B6D6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolMinusFaceDoublingMethod({\mdseries\slshape pol, adr})\index{PolMinusFaceDoublingMethod@\texttt{PolMinusFaceDoublingMethod}}
\label{PolMinusFaceDoublingMethod}
}\hfill{\scriptsize (функция)}}\\


 Допустим,
некоторая
окрестность
k-клетки $a$ в
pl-комплексе $M$ обладает
окрестностью
эквивалентной
нескольким
копиям
n-дисков $D^n_i$ склеенных
по
представленной
клетке $a.$ Тогда
можно
осуществить
разрез
по
данной
клетке
в
pl-многообразии
более
экономичным
способом,
создав
для
каждого
n-диска $D^n_i$ свою
копию
клетки $a.$ В
качестве
примера
приведем
букет
трех
отрезков,
склеенный
по
вершине
[0,1]. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@buket:=rec( vertices := [ 1, 2, 3, 4 ],|
  faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ] ] ] );;
  !gapprompt@gap>| !gapinput@PolMinusFaceDoublingMethod(buket,[0,1]);|
  rec( vertices := [ 1, 2, 3, 4, 5, 6 ],
   faces:=[ [ [ 1, 2 ], [ 3, 5 ], [ 4, 6 ] ] ] )
  					
\end{Verbatim}
 Каждый
диск $D^n_i$ может
иметь
свое
подразбиение
внутри
pl-многообразия $M.$ При
этом
очевидно,
что в
pl-комплексе
существует
такое
подразбиение
шарового
комплекса,
что
линк
клетки $a$ распадается
на
несколько
связных
компонент
(по
числу
дисков $D^n_i$).
Именно
это
свойство
взято
в
качестве
критерия
нахождения
и
разделения
дисков $D^n_i.$ Данное
вырезание
не
затрагивает
границу
клетки,
оставляя
ее на
месте,
при
этом
индексы
не
участвующих
в
разрезании
клеток
не
изменяются.  }

 

\subsection{\textcolor{Chapter }{PolMinusPol}}
\logpage{[ 2, 1, 6 ]}\nobreak
\hyperdef{L}{X804271D78379B73C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolMinusPol({\mdseries\slshape pol, subpol, dim})\index{PolMinusPol@\texttt{PolMinusPol}}
\label{PolMinusPol}
}\hfill{\scriptsize (функция)}}\\


 Функция
вырезает
подполитоп $subpol$ из
политопа $pol$. По
возможности
выбирается
такой
способ
вырезания,
который
будет
более
экономичным. }

 

\subsection{\textcolor{Chapter }{GlueFaces}}
\logpage{[ 2, 1, 7 ]}\nobreak
\hyperdef{L}{X79DD05937B0FD9D2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GlueFaces({\mdseries\slshape pol, face1, face2})\index{GlueFaces@\texttt{GlueFaces}}
\label{GlueFaces}
}\hfill{\scriptsize (функция)}}\\


 Склеить
две
клетки
в
многообразие
у
которых
общая
граница.
Замечание:
функция
не
проверяет
действительно
ли у
клеток
одинаковая
граница.
Так же
проверку,
что
после
склейки
получаются
корректные
данные
возлагаем
на
пользователя.
Например,
функнция
будет
работать
в
следующем
случае
некорректно: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  gap>d2:=ballAB(2);;
  gap>GlueFaces(d2,[1,2],1);
  rec(faces:=[ [ [1,2] ], [ [1] ] ],
  	vertices:= ["A","B"]
  					
\end{Verbatim}
 Как мы
видим
из
примера
полученные
данные
уже не
являются $pl$-разбиением. }

 

\subsection{\textcolor{Chapter }{VerticesRullGlueFace}}
\logpage{[ 2, 1, 8 ]}\nobreak
\hyperdef{L}{X7D9ACC967D3ACE2A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{VerticesRullGlueFace({\mdseries\slshape pol, para, dim})\index{VerticesRullGlueFace@\texttt{VerticesRullGlueFace}}
\label{VerticesRullGlueFace}
}\hfill{\scriptsize (функция)}}\\


 Производится
склейка
двух
клеток
политопа.
Клетки
индексы
клеток
помещаются
в
список
para,
размерность
dim
клеток
указывается
отдельно. }

 

\subsection{\textcolor{Chapter }{VerticesRullGluePol}}
\logpage{[ 2, 1, 9 ]}\nobreak
\hyperdef{L}{X86C045E57D71AB84}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{VerticesRullGluePol({\mdseries\slshape pol, subpol1, subpol2, dim})\index{VerticesRullGluePol@\texttt{VerticesRullGluePol}}
\label{VerticesRullGluePol}
}\hfill{\scriptsize (функция)}}\\


 Функция
предоставляет
возможность
провести
склейку
внутри
политопа.В
политопе
должны
быть
указаны
два
подполитопа
размерности $k$,
причем
их
разбиения
должны
быть
одинаковыми,
так же
эти
разбения
должны
обладать
хотябы
одной $k$-клеткой
с $k+1$ вершиной
или
более. 

 Правила
склейки
задаются
заранее
в
списке
имен
вершин
политопа,
то
есть в $pol.veritces$.
Функция
ищет
все
вершины
с
одинаковыми
именами
и
склеивает
их в
одну.
Далее
весь
процесс
продолжается
по
индукции
на
клетки
subpol1 и subpol2
более
высоких
размерностей.
Наличием $k$-клетки
хотябы
c $k+1$ вершиной
обеспечивается
однозначность
склейки. 

 Для
склейки
двух
политопов
с
помощью
данной
функции
можно
воспользоваться
свободным
объединением
FreeUnionPol. }

 }

 }

 
\chapter{\textcolor{Chapter }{Погружения
и узлы}}\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X82CA5E1F7B3D3A5C}{}
{
 Пакет $PL$ предоставляет
возможность
работы
с
одномерными
узлами
и
двумерными
заузленными
поверхностями. 
\section{\textcolor{Chapter }{Классические
узлы}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7EE9F2A87F05B455}{}
{
 В
пакете
PL
имеется
возможность
задания
диаграммы
узла
двумя
различными
способами
каждый
из
которых
имеет
свои
плюсы
и свои
минусы. 
\subsection{\textcolor{Chapter }{Способы
задания
диаграммы
узла.}}\logpage{[ 3, 1, 1 ]}
\hyperdef{L}{X7D40248E7D685A1A}{}
{
 Первый
способ
основан
на том,
что
диаграмме
узла
сопоставляются
атрибуты
которые
однозначно
характеризуют
диаграмму.
Для
этого
присвоим
имена
каждой
двойной
точке,
которые
назовем
образующими
и
выберем
на
узле
произвольным
образом
начальную
точку
и
положительное
направление,
причем
диаграмму
можно
построить
так,
что бы
отмеченная
точка
не
стала
при
проекции
двойной
точкой.
При
обходе
диаграммы
начиная
от
отмеченной
точки
по
выбранному
направлению
можно
составить
слово
по
следующему
правилу:
на
начальном
этапе
имеем
пустое
слово,
далее
каждая
встреченная
двойная
точка
приписывается
к
слову
справа
в
степени $-1$ если
мы
пришли
в эту
точку
снизу
и в
степени $1$ если
пришли
сверху.
Когда
мы
вернемся
в
начальную
точку,
создание
слова
заканчивается.
Дополнительно,
каждая
двойная
точка
имеет
свою
ориентацию
которую
образует
выбранное
нами
направление.  Ориентацию
двойной
точки
предлагается
строить
так. В
двойной
точке
строится
два
вектора $v_1$ и $v_2,$ где $v_1$ ---
касательный
вектор
к
верхней
дуге
диаграммы
на
плоскости, $v_2$ --- к
нижней.
В
качестве
ориентации
этой
точки
выбирается
знак
построенного
репера.  Воспользуемся
данным
описанием
и
составим
необходимые
атрибуты
для
задания
узла
трилистника.
Для
трилистника
будет
составлено
слово $ac^{-1}ba^{-1}cb^{-1}$ и для
каждой
двойной
точки
диаграммы
каждая
двойная
точка
этой
диаграммы
имеет
отрицательную
ориентацию.
Если
данные
ориентации
заменить
на
противоположные,
то
будет
создана
зеркальная
диаграмма
к
указанной.
Ниже
представлена
диаграмма
узла
трилистника
включенная
в
библиотеку
пакета $PL.$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@Trefoil;|
  rec( kod := [ [ "a", 1 ], [ "c", -1 ], [ "b", 1 ],
                [ "a", -1 ], [ "c", 1 ], [ "b", -1 ] ],
       orient := [ [ "a", -1 ], [ "b", -1 ], [ "c", -1 ] ] )
    				
\end{Verbatim}
 Как
видно
из
примера
вся
необходимая
информация
собрана
в
списках
.kod и .orient.
Слово
которое
составляется
при
обходе
узла
представлено
списком
.kod
который
содержит
двухэлементные
списки,
первым
элементом
которого
является
имя
двойной
точки,
вторым $\pm 1$ в
зависимости
от
степени
соответствующей
образующей
в
слове.
Сравните
слово $ac^{-1}ba^{-1}cb^{-1}$ составленное
по
трилистнику
со
списком
Trefoil.kod.
Далее,
список
.orient
составлен
из
списка
пар,
первый
элемент
пары ---
имя
двойной
точки,
второй
ориентация.  Задание
таким
образом
зацеплений
несколько
усложняется
тем,
что
необходимо
отдельно
указывать
компоненты
зацепления.
В
случае,
если
стоит
необходимость
вручную
задать
диаграмму
обычного
узла
данный
способ
является
лучшим
поскольку
информация
легко
проверяется.
Предполагается,
что
данная
диаграмма
лежит
на
двумерной
плоскости,
отсюда
мы
будем
называть
этот
способ
задания
--
плоским,
что бы
различать
два
способа
описания
диаграмм
узлов.
Второй
способ
задания
диаграммы
узла
основан
на той
идее,
что
диаграмма
узла
естественным
образом
создает
разбиение
двумерной
плоскости,
а
следовательно
аналогичное
разбиение
можно
выбрать
и на
сфере $S^2$ после
одноточечной
компактификации.
Отсюда,
для
удобства,
этот
способ
далее
будем
называть
сферическим.
Итак,
этот
способ
описания
диаграммы
заключается
в
создании
такого
шарового
разбиения
двумерной
сферы
по
клеткам
которого
проходят
дуги
диаграммы
узла.
То
есть
дополнительно
к $pl-$разбиению
присоединяется
информация
о
дугах
диаграммы
узла и
о том
как
ведут
себя
дуги в
районе
двойной
точки.
В
случае
классических
узлов
достаточно
указать
все
1-клетки
по
которым
проходят
клетки
узла.
Двойные
точки
вычисляются
уже из
представленной
информации,
но для
каждой
двойной
точки
необходимо
знать
какая
дуга
выше,
какая
ниже. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  rec(
    1knot :=
      rec(
        dpoints := rec( 1 := [ 6, 1, 3, 4 ], 2 := [ 2, 3, 5, 6 ],
            3 := [ 4, 5, 1, 2 ] ), sheets := [ 1 .. 6 ] ),
    faces := [ [ [ 1, 3 ], [ 2, 3 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2 ] ],
        [ [ 1, 3, 5 ], [ 1, 4 ], [ 2, 4, 6 ], [ 2, 5 ], [ 3, 6 ] ] ],
    vertices := [ "a", "b", "c" ] )
  			
\end{Verbatim}
 В
данном
примере
приведена
диаграмма
узла
трилистника
расположенная
на
двумерной
сфере.
Сначала,
обратим
внимание,
что
вся
информация
касающаяся
узла
помещена
в
именованный
список
.1knot, в
котором
содержатся
списки
.sheets всех
1-клеток $pl-$разбиения
по
которому
проходит
диаграмма
и .dpoints
который
в
качестве
именованных
полей
содержит
индексы
вершин,
а в
качестве
соответствующих
объектов
списки
из
четырех
элементов
в
которых
первая
пара
элементов
это
индексы
1-клеток
входящих
в
верхнюю
дугу
диаграммы
в этой
точке,
последняя
пара ---
индексы
1-клеток
входящих
в
нижнюю
дугу
диаграммы
в
данной
точке.  Данная
конструкция
неудобна
для
описания
ее
напрямую
по
диаграмме
узла
поскольку
содержит
излишнюю
информацию,
но с
другой
стороны
предложенный
способ
обладает
двумя
преимуществами.
Во-первых,
это
задание
может
напрямую
работать
с
диаграммами
зацеплений
узлов.
Во-вторых,
такое
задание
легко
обобщается
на
двумерные
заузленные
поверхности,
о чем
будет
рассказано
ниже. }

  

\subsection{\textcolor{Chapter }{Knot1OnSphere2}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X7879B1EE80994B6E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Knot1OnSphere2({\mdseries\slshape knot})\index{Knot1OnSphere2@\texttt{Knot1OnSphere2}}
\label{Knot1OnSphere2}
}\hfill{\scriptsize (функция)}}\\


 По
диаграмме
узла
создается
двумерная
сфера $S^2,$ в
разбиении
которой
указана
данная
диаграмма.
Узел
содержится
в
прикрепленном
именованном
списке
.1knot,
который
построен
в
стиле
задания
диаграмм
двумерных
заузленных
поверхностей. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@Knot1OnSphere2(Figure8);|
  rec(
    1knot :=
      rec(
        dpoints := rec( 1 := [ 8, 1, 4, 3 ], 2 := [ 4, 5, 8, 7 ],
            3 := [ 2, 3, 5, 6 ], 4 := [ 6, 7, 1, 2 ] ), sheets := [ 1 .. 8 ] ),
    faces :=
      [ [ [ 1, 4 ], [ 3, 4 ], [ 1, 3 ], [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 2, 4 ],
            [ 1, 2 ] ],
        [ [ 1, 3, 6 ], [ 1, 4, 7 ], [ 2, 5, 7 ], [ 2, 6 ], [ 3, 5, 8 ], [ 4, 8 ]
           ] ], vertices := [ "a", "b", "c", "d" ] )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{KnotInS3}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X7A626B2A84CAD77E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{KnotInS3({\mdseries\slshape knot})\index{KnotInS3@\texttt{KnotInS3}}
\label{KnotInS3}
}\hfill{\scriptsize (функция)}}\\


 Создает
трехмерную
сферу
в
которую
вложен
узел.
Клетки
узла
указаны
в result.knot. }

 

\subsection{\textcolor{Chapter }{Reidemeister10Everywhere}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X7D7395747EC32627}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Reidemeister10Everywhere({\mdseries\slshape knot})\index{Reidemeister10Everywhere@\texttt{Reidemeister10Everywhere}}
\label{Reidemeister10Everywhere}
}\hfill{\scriptsize (функция)}}\\


 Проверяет
диаграмму
узла
на
наличие
в ней
свободных
петель,
которые
можно
убрать
первым
движением
Райдемайстера $R^{-1}_0.$ Число $10$ в
названии
обозначает,
что
применяется
движение
Райдемайстера,
которое
берет
локально
одну
вершину
и
создает
из
него
ноль
вершин,
если
такое
движение
применимо. }

 

\subsection{\textcolor{Chapter }{ZeroLinkFromKnot}}
\logpage{[ 3, 1, 5 ]}\nobreak
\hyperdef{L}{X7E710DED7C4E5B3A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZeroLinkFromKnot({\mdseries\slshape knot})\index{ZeroLinkFromKnot@\texttt{ZeroLinkFromKnot}}
\label{ZeroLinkFromKnot}
}\hfill{\scriptsize (функция)}}\\


 Не
изменяя
самого
узла,
данная
функция
создает
такую
диаграмму,
которая
будет
иметь
нулевой
коэффициент
зацепления
с
диаграммой
составленной
следующим
образом.
Для
узла
создается
трубчатая
окрестность
в
трехмерном
пространстве.
Проекция
узла
параллельно
оси $Oz$ на
трубчатую
окрестность
создает
новый
узел
(по
сути
дела
тот же
самый).
Два
узла
созданных
по
предложенной
диаграмме
образуют
зацепление
с
нулевым
коэффициентом. }

 

\subsection{\textcolor{Chapter }{KnotGroup}}
\logpage{[ 3, 1, 6 ]}\nobreak
\hyperdef{L}{X797F8D4A848DD9BC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{KnotGroup({\mdseries\slshape knot})\index{KnotGroup@\texttt{KnotGroup}}
\label{KnotGroup}
}\hfill{\scriptsize (функция)}}\\


 Вычисляется
фундаментальная
группа
узла,
которая
определяется
как
фундаментальная
группа
дополнения
узла в
трехмерной
сфере $S^3.$ Для
создания
группы
используются
соотношения
Виртингера. }

    

\subsection{\textcolor{Chapter }{TorusKnot}}
\logpage{[ 3, 1, 7 ]}\nobreak
\hyperdef{L}{X7EB8D0A97D7D5E57}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TorusKnot({\mdseries\slshape q, p})\index{TorusKnot@\texttt{TorusKnot}}
\label{TorusKnot}
}\hfill{\scriptsize (функция)}}\\


 Создается
диаграмма
торического
узла $(q,p),$ если $q$ и $p$ взаимнопростые,
если
это не
так, то
будет
создано
соответствующее
зацепление.
Параметр $q > 0$ соответствует
количеству
нитей,
а
параметр $p$ соответствует
количеству
оборотов. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@k:=TorusKnot(2,3);|
  rec( kod := [ [ 1, 1 ], [ 2, -1 ], [ 3, 1 ], [ 1, -1 ], [ 2, 1 ], [ 3, -1 ] ],
    orient := [ [ 1, 1 ], [ 2, 1 ], [ 3, 1 ] ] )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ZeifertSurface}}
\logpage{[ 3, 1, 8 ]}\nobreak
\hyperdef{L}{X8575EC5C7B564A45}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZeifertSurface({\mdseries\slshape knot})\index{ZeifertSurface@\texttt{ZeifertSurface}}
\label{ZeifertSurface}
}\hfill{\scriptsize (функция)}}\\


 создает
поверхность
Зейферта
узла,
вложенную
в
трехмерную
сферу.
Все
2-клетки
отвечающие
поверхности
Зейферта
собраны
в
списке
.zeifert
прикрепленному
к
политопу. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@pol:=ZeifertSurface(Knot7_7);;|
  !gapprompt@gap>| !gapinput@zeif:=SubPolytope(pol, pol.zeifert, 2);;|
  !gapprompt@gap>| !gapinput@PolOrient(zeif);|
  [ 1, 1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, 1 ]
  					
\end{Verbatim}
 В
данном
примере
мы
создали
сферу
с
указанной
в ней
поверхностью
Зейферта,
выделили
ее как
самостоятельный
политоп
и
проверили
является
ли эта
поверхность
ориентируемой.
Тем
самым
мы
проиллюстрировали
ориентируемость
полученного
объекта. }

 

\subsection{\textcolor{Chapter }{ZeifertSurfaceWithSimplyBoundary}}
\logpage{[ 3, 1, 9 ]}\nobreak
\hyperdef{L}{X7D8D06467FBEB8CF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZeifertSurfaceWithSimplyBoundary({\mdseries\slshape knot})\index{ZeifertSurfaceWithSimplyBoundary@\texttt{ZeifertSurfaceWithSimplyBoundary}}
\label{ZeifertSurfaceWithSimplyBoundary}
}\hfill{\scriptsize (функция)}}\\


 создает
поверхность
Зейферта
узла $knot,$ чья
граница
состоит
только
из
двух
1-клеток
(соответственно
по
которым
и
проходит
сам
узел). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@pol:=ZeifertSurfaceWithSimplyBoundary(Knot7_7);;|
  !gapprompt@gap>| !gapinput@SetOfFacesBoundary(pol,pol.zeifert,2);|
  [ 49, 159 ]
  				
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Двумерные
заузленные
поверхности}}\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X8272DC908591F12A}{}
{
 Под
заузленной
двумерной
поверхностью
(surface-knot) мы
понимаем
связную
или не
связную
поверхность
помещенную
в
четырехмерное
евклидово
пространство $\mathbb{R}^4.$ Проекция $\pi : \mathbb{R}^4 \to \mathbb{R}^3$ общая (is generic)
для
заузленной
поверхности $T$ если
если
образ $\pi (T) $ из $\mathbb{R}^3$ локально
гомеоморфен
1)
простому
диску 2)
двум
трансверсально
пересекающимся
дискам
3) трем
трансверсально
пересекающимся
дискам
или 4)
зонтику
Уитни.
Точки
имеющие
окрестности
с 2) по 4)
называются
двойными
точкаи,
тройными
точками
и
точками
ветвления
общей
проекции,
соответственно.
Множество
всех
точек
типа 2),3) и 4)
называется
графом
двойных
точек (singularity
set).
Диаграммой
поверхности $T$ называют
образ $\pi (T)$ с
добавлением
информации
пересечения
на
графе
двойных
точек.
Для
каждой
лини
двойных
точек
должно
быть
определено
отношение
высот
для
листов
которые
входят
в это
ребро. 
\subsection{\textcolor{Chapter }{Задание
двумерных
заузленных
поверхностей}}\logpage{[ 3, 2, 1 ]}
\hyperdef{L}{X7BC82E957ADB11FC}{}
{
 Аналогично
одномерным
узлам,
диаграммы
двумерных
заузленных
поверхностей
могут
быть
рассмотрены
уже
внутри
разбиения
трехмерной
сферы $S^3.$ В
качестве
такой
диаграммы
мы
понимает
шаровое
разбиение
трехмерной
сферы
по
клеткам
которой
проходят
листы
двумерной
заузленной
поверхности.
Вся
информация
о
диаграмме
внутри
политопа
собирается
в
прикрепленном
именованном
списке
.2knot.
Список
.2knot
содержит
список
.sheets в
котором
собраны
индексы
всех
2-клеток
шарового
разбиения
по
которым
проходит
диаграмма
заузленной
поверхности
и
именованный
список
.dpoints в
котором
именами
выступают
ребра
двойных
точек.
В
списке
.2knot.dpoints
каждому
двойному
ребру
поставлен
в
соответствие
четырехэлементный
список
индексов
2-клеток
диаграммы
лежащих
в
звезде
данного
двойного
ребра.
На
четрыхэлементном
списке
выбрано
следующее
упорядочение,
первые
два
индекса
соответствуют
2-клеткам
в
звезде
ребра
лежащие
на
верхнем
листе,
последние
два
это
индексы
2-клеток
на
нижнем.
Данной
информации
о
диаграмме
двумерной
заузленной
поверхности
достаточно
чтобы
вычислить
тройные
точки
и
точки
ветвления.
Внутри
программ
мы не
будем
проводить
четкого
разделения
между
двумерными
заузленными
поверхностями
и
двумерными
узлами.
Вся
информация
о
данных
структурах
будет
собираться
в
прикрепленном
списке
.2knot. }

 

\subsection{\textcolor{Chapter }{PolSimplifyWith2Knot}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X845EC0BA802775BB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolSimplifyWith2Knot({\mdseries\slshape pol})\index{PolSimplifyWith2Knot@\texttt{PolSimplifyWith2Knot}}
\label{PolSimplifyWith2Knot}
}\hfill{\scriptsize (функция)}}\\


 Упрощает
политоп
содержащий
2-узел. В
качестве
упрощающей
функции
была
выбрана
функция
UnionFaces,
которая
объединяет
два
шара в
политопе.
Так же
как и
функция
PolSimplify
данная
функция
не
проверяет
возможны
ли
дальнейшие
упрощение
политопа $pol.$ Для
этой
проверки
необходимо
еще
раз
запустить
эту
функцию
на
вновь
полученных
данных. }

 

\subsection{\textcolor{Chapter }{SingularitySet2Knot}}
\logpage{[ 3, 2, 3 ]}\nobreak
\hyperdef{L}{X859D50D9858D5B25}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SingularitySet2Knot({\mdseries\slshape pol})\index{SingularitySet2Knot@\texttt{SingularitySet2Knot}}
\label{SingularitySet2Knot}
}\hfill{\scriptsize (функция)}}\\


 Singularity set --- граф
двойных
точек
диаграммы
2-узла. В
графе
перечислены
все
1-клетки
объемлющего
политопа $pol$ которые
содеражт
описываемый
граф.
Так же
в
соответствии
каждой
вершине
сопоставлен
список.
Данный
список
строится
из
звезды $Star(v)$ в
описываемом
графе
упорядоченной
таким
образом.
Первая
пара
элементов
принадлежит
верхней
линии
двойных
точек
в этой
вершине
(получаемая
на
пересечении
верхнего
и
среднего
листов),
вторая
пара
элементов
принадлежит
средней
линии
двойных
точек
(пересечение
верхнего
и
нижнего
листов)
и
третья
пара
принадлежит
нижней
линии
двойных
точек
(пересечение
среднего
и
нижнего
листов).
Таким
образом
соответсвующие
списки
для
тройной
точки
будут
состоять
из
шести
элементов,
для
двойной
точки
из
двух и
для
точки
ветвления
из
одного. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@SingularitySet2Knot(TurnKnot(Trefoil,2));|
  	...
  rec( graf := [ 7, 4, 5, 6, 19, 20, 21, 22, 17, 18, 23, 8, 9, 10, 12, 45, 32,
        31, 25, 26, 51, 54, 55, 64, 112, 113, 114, 115, 134, 136, 137, 138,
        131, 130, 129, 119, 109, 118, 127, 106, 124, 105, 123, 104, 122, 102,
        99, 98, 79, 97, 78, 53, 94, 52, 59, 93, 92, 57, 73, 56, 72, 90, 70, 69,
        68, 67, 66, 65 ],
    order := rec( 1 := [ 137, 92 ], 10 := [ 12, 102 ], 11 := [ 10, 12 ],
        13 := [ 4 ], 14 := [ 22, 17, 19, 20, 104, 97 ],
        15 := [ 19, 18, 21, 22, 105, 98 ], 16 := [ 20, 21, 18, 23, 106, 99 ],
        19 := [ 25 ], 2 := [ 138, 94 ], 20 := [ 32, 31, 25, 26, 109, 102 ],
        21 := [ 23, 26 ], 23 := [ 17, 32 ], 24 := [ 31, 112 ],
        25 := [ 113, 104 ], 26 := [ 114, 105 ], 27 := [ 115, 106 ],
        30 := [ 45, 109 ], 34 := [ 45, 112 ], 36 := [ 113, 118 ],
        37 := [ 115, 119 ], 40 := [ 51, 56, 54, 53, 118, 122 ],
        41 := [ 53, 52, 55, 56, 114, 123 ], 42 := [ 54, 55, 52, 57, 119, 124 ],
        45 := [ 127, 59 ], 46 := [ 59, 57 ], 48 := [ 51 ],
        49 := [ 64, 69, 67, 66, 129, 122 ], 5 := [ 4, 9, 7, 6, 97, 92 ],
        50 := [ 66, 65, 69, 68, 130, 123 ], 51 := [ 68, 67, 70, 65, 131, 124 ],
        54 := [ 72 ], 55 := [ 79, 78, 73, 72, 134, 127 ], 56 := [ 73, 70 ],
        58 := [ 64, 79 ], 59 := [ 136, 78 ], 6 := [ 5, 6, 8, 9, 98, 93 ],
        60 := [ 137, 129 ], 61 := [ 130, 93 ], 62 := [ 138, 131 ],
        64 := [ 134, 90 ], 67 := [ 136, 90 ], 7 := [ 7, 8, 5, 10, 99, 94 ] ) )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{TripleDoubleBranchPoints}}
\logpage{[ 3, 2, 4 ]}\nobreak
\hyperdef{L}{X81D8934B80A7BE6A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TripleDoubleBranchPoints({\mdseries\slshape pol})\index{TripleDoubleBranchPoints@\texttt{TripleDoubleBranchPoints}}
\label{TripleDoubleBranchPoints}
}\hfill{\scriptsize (функция)}}\\


 Для
шарового
разбиения
многообразия,
внутри
которого
указана
диаграмма
заузленной
поверхнсоти
вычисляются
те
вершины
политопа,
которые
являются
тройными
точками,
двойными
точками
или
точками
ветвления.
По
возможности
для
каждой
точки
указываются
2-клетки
диаграммы
группированные
по
принадлежности
различным
листам.
Функция
выводит
именованный
список
с
полями
.triple, .double и .branch. В
именованном
списке
result.triple
каждой
вершине $v$ под
списком
поля .u
можно
узнать
2-клетки
звезды
на
верхнем
листе
в
тройной
точке $v$, под
списком
.m ---
2-клетки
на
среднем
листе
и под
списком
.d --- на
нижнем.
Для
двойной
точки
указываются
только
списки
.u и .d. Для
точки
ветвления
указан
только
список
2-клеток
узла
лежащих
в
звезде
этой
вершины. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
   gap> pol:=TurnKnot(Trefoil,1);;
   ...
   gap> TripleDoubleBranchPoints(pol);
  rec( branch := rec( 13 := [ 2, 6, 22, 30 ], 19 := [ 13, 16, 37, 44 ] ),
    double :=
      rec( 1 := rec( d := [ 24, 25, 41, 57 ], u := [ 22, 57, 51, 27 ] ),
        10 := rec( d := [ 28, 37, 38 ], u := [ 2, 30, 7 ] ),
        11 := rec( d := [ 28, 36, 38 ], u := [ 2, 6, 7 ] ),
        2 := rec( d := [ 23, 28, 55, 52, 55 ], u := [ 25, 41, 26 ] ),
        21 := rec( d := [ 36, 38, 43 ], u := [ 8, 12, 14 ] ),
        23 := rec( d := [ 30, 39, 48 ], u := [ 8, 12, 16 ] ),
        24 := rec( d := [ 7, 46, 47 ], u := [ 13, 44, 14 ] ),
        25 := rec( d := [ 24, 40, 41 ], u := [ 27, 39, 51 ] ),
        26 := rec( d := [ 26, 42, 27 ], u := [ 23, 24, 40 ] ),
        27 := rec( d := [ 23, 43, 52 ], u := [ 26, 42, 41 ] ),
        30 := rec( d := [ 47, 48, 51, 57 ], u := [ 19, 44, 20, 43 ] ),
        34 := rec( d := [ 46, 54, 57, 47 ], u := [ 14, 20, 19, 44 ] ) ),
    triple :=
      rec(
        14 := rec( d := [ 32, 33, 40, 41 ], m := [ 27, 30, 35, 39 ],
            u := [ 8, 9, 11, 12 ] ),
        15 := rec( d := [ 27, 34, 35, 42 ], m := [ 23, 31, 32, 40 ],
            u := [ 9, 10, 11, 12 ] ),
        16 := rec( d := [ 23, 31, 36, 43 ], m := [ 33, 34, 41, 42 ],
            u := [ 8, 9, 10, 12 ] ),
        20 := rec( d := [ 37, 38, 43, 44 ], m := [ 7, 30, 47, 48 ],
            u := [ 8, 13, 14, 16 ] ),
        5 := rec( d := [ 24, 25, 32, 33 ], m := [ 22, 27, 30, 35 ],
            u := [ 2, 3, 5, 6 ] ),
        6 := rec( d := [ 26, 27, 34, 35 ], m := [ 23, 24, 31, 32 ],
            u := [ 3, 4, 5, 6 ] ),
        7 := rec( d := [ 23, 28, 31, 36 ], m := [ 25, 26, 33, 34 ],
            u := [ 2, 3, 4, 6 ] ) ) )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsDiagrammOf2Knot}}
\logpage{[ 3, 2, 5 ]}\nobreak
\hyperdef{L}{X8448826B8111EC48}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsDiagrammOf2Knot({\mdseries\slshape pol})\index{IsDiagrammOf2Knot@\texttt{IsDiagrammOf2Knot}}
\label{IsDiagrammOf2Knot}
}\hfill{\scriptsize (функция)}}\\


 Проверяет
диаграмму
2-узла
вложенную
в
трехмерное
многообразие.
Для
этого
проверяются:
1)
корректность
всех
ссылок
на
клетки
политопа,
2) граф
двойных
точек, 3)
отсутствие
точек
самокасания. 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Пример]
   gap> pol:=TurnKnot(Figure8,-1);;
  
    All good!
  
   gap> IsDiagrammOf2Knot(pol);
   true
  					
\end{Verbatim}
 }

  

\subsection{\textcolor{Chapter }{SurfaceOf2Knot}}
\logpage{[ 3, 2, 6 ]}\nobreak
\hyperdef{L}{X870383C87924E495}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SurfaceOf2Knot({\mdseries\slshape M3})\index{SurfaceOf2Knot@\texttt{SurfaceOf2Knot}}
\label{SurfaceOf2Knot}
}\hfill{\scriptsize (функция)}}\\


 Для
заузленной
поверхности
указанной
внутри
некоторого
3-многообразия $M^3$ создается
прообраз
этой
поверхности
с
указанием
прообразов
двойных
ребер,
тройных
точек
и
точек
ветвления.
Прообраз
создается
как
pl-комплекс,
к
которому
прикреплена
дополнительная
информация
содеражащаяся
в
именнованном
списке $.preimage$,
который
является
списком
дублированных
прообразов.
В него
входят
список $.1$ и $.0.$ Список $.1$ это
список
пар
содержий
прообразы
для
каждого
двойного
ребра,
первым
элементом
пары
является
ребро-прообраз
лежащее
на
нижнем
листе,
вторым,
соответственно,
ребро-прообраз
лежащее
на
верхнем
листе
образа
в
диаграмме.
Список $.0$ состоит
из
списков
длины 1
и 3,
которые
являются
списками
прообразов
точек
ветвления
и
тройных
точек,
соответственно.
Причем,
для
тройных
точек
прообраз
точки,
лежащий
на
верхнем
листе
будет
третьим
в
списке,
на
среднем
-
вторым
и на
нижнем,
соответственно,
первым. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{TurnKnot}}
\logpage{[ 3, 2, 7 ]}\nobreak
\hyperdef{L}{X857BA8697BA2F587}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TurnKnot({\mdseries\slshape knot, number})\index{TurnKnot@\texttt{TurnKnot}}
\label{TurnKnot}
}\hfill{\scriptsize (функция)}}\\


 Cоздается
диаграмма
2-узла
вложенная
в
трехмерную
сферу $S^3$ с
помощью
алгоритма
SpunTwist на
основании
диаграммы
одномерного
узла $knot$. Число $number$ задает
количество
оборотов
данной
диаграммы
при
осуществлении
twist-движения,
при
этом
отрицательный
знак
данного
числа
задает
обращение
узла в
противоположном
направлении,
при
этом
если $number$ указать
равным
нулю,
тогда
twist-оборотов
в
диаграмме
не
будет
и мы
получим
простую
spun-диаграмму. 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Пример]
  @gapprompt|gap>B @gapinput|TurnKnot(Trefoil,0);B
  I'm trying simplify a polytope.
  
    ...
  
   All good!
  
  rec(
    2knot :=
      rec( dpoints := rec( 11 := [ 12, 7, 9, 10 ], 12 := [ 8, 9, 11, 12 ],
            13 := [ 10, 11, 13, 8 ], 14 := [ 18, 7, 15, 16 ],
            15 := [ 14, 15, 17, 18 ], 16 := [ 16, 17, 13, 14 ] ),
        sheets := [ 7, 8, 14, 9, 15, 10, 16, 11, 17, 12, 18, 13 ] ),
    faces :=
      [ [ [ 2, 3 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2 ], [ 5, 6 ], [ 4, 5 ],
            [ 4, 6 ], [ 5, 6 ], [ 4, 5 ], [ 1, 4 ], [ 2, 5 ], [ 3, 6 ],
            [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ],
        [ [ 1, 3, 5 ], [ 1, 4 ], [ 2, 5 ], [ 6, 8, 10 ], [ 6, 9 ], [ 7, 10 ],
            [ 11, 14 ], [ 1, 6, 12, 13 ], [ 2, 7, 11, 12 ], [ 3, 8, 11, 13 ],
            [ 4, 9, 12, 13 ], [ 5, 10, 11, 12 ], [ 13, 16 ], [ 1, 6, 15, 16 ],
            [ 2, 7, 14, 15 ], [ 3, 8, 14, 16 ], [ 4, 9, 15, 16 ],
            [ 5, 10, 14, 15 ] ],
        [ [ 7, 10, 13, 16 ], [ 1, 4, 8, 10, 12 ], [ 2, 5, 8, 11 ],
            [ 3, 6, 9, 12 ], [ 1, 4, 14, 16, 18 ], [ 2, 5, 14, 17 ],
            [ 3, 6, 15, 18 ] ] ],
    vertices := [ [ 1, "a" ], [ 1, "b" ], [ 1, "c" ], [ 2, "a" ], [ 2, "b" ],
        [ 2, "c" ] ] )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{2KnotInS4}}
\logpage{[ 3, 2, 8 ]}\nobreak
\hyperdef{L}{X848FEA1F80CF0734}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{2KnotInS4({\mdseries\slshape pol})\index{2KnotInS4@\texttt{2KnotInS4}}
\label{2KnotInS4}
}\hfill{\scriptsize (функция)}}\\


 По
трехмерному
политопу $pol$ в
котором
содержится
диаграмма
заузленной
двумерной
поверхности $T$ создается
вложение
этой
поверхности $T$ в
четырехмерную
сферу $S^4.$ }

 

\subsection{\textcolor{Chapter }{OrientBrockenDiagramm}}
\logpage{[ 3, 2, 9 ]}\nobreak
\hyperdef{L}{X780890177ADEBF2C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OrientBrockenDiagramm({\mdseries\slshape s3})\index{OrientBrockenDiagramm@\texttt{OrientBrockenDiagramm}}
\label{OrientBrockenDiagramm}
}\hfill{\scriptsize (функция)}}\\


 Функция
построит
разорванную
диаграмму
для
ориентируемой
линейно
связной
заузленной
поверхности. 

 Для
ориентируемого
2-узла
вычисляется
информация
о
данной
диаграмме
в
которую
входят
разорванная
диаграмма
2-узла и
граф
двойных.
На
выход
подается
именованный
список. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@s3:=TurnKnot(Trefoil,2);;|
  !gapprompt@gap>| !gapinput@rez:=OrientBrockenDiagramm(s3);;|
  !gapprompt@gap>| !gapinput@RecNames(date);          |
  [ "images", "preimages", "manifold", "colines", "cosheets", "cofaces", 
    "coorient" ]
  					
\end{Verbatim}
 

 Список $rez.manifold$ содержит
политоп
прообраз
двумерной
заузленной
поверхности,
то
есть
2-многообразие. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@RecNames(rez.manifold);  |
  [ "vertices", "faces" ]
  					
\end{Verbatim}
 

 Список $rez.images$ содержит
образы
сингулярных
точек
диаграммы
заузленной
поверхности. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@PrintObj(rez.images);|
  rec(
    0 := [ 4, 5, 6, 11, 12, 13, 14, 17, 18, 38, 39, 40, 45, 46, 47, 48, 51, 52 
       ],
    1 := [ 7, 4, 5, 6, 19, 20, 21, 22, 24, 16, 17, 18, 8, 9, 10, 11, 25, 54, 
                  . . .
  					
\end{Verbatim}
 В
списке $rez.images.0$ содержатся
индексы
вершин
из
политопа $s3$,
которые
являются
тройными
точками
или
точками
ветвления.
В
списоке $rez.images.1$ собраны
индексы
ребер
из $s3$ которые
являются
двойными
линиями
диаграммы. 

 Список $rez.preimages$ содержит
прообразы
сингулярных
точек
диаграммы
заузленной
поверхности. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@PrintObj(rez.preimages);|
  rec(
    0 := [ [ 69, 4, 70 ], [ 71, 5, 72 ], [ 6, 73, 74 ], [ 11 ], 
                  . . .
    1 := [ [ 7, 143 ], [ 4, 144 ], [ 5, 145 ], [ 6, 146 ], [ 19, 147 ], 
                  . . .
  					
\end{Verbatim}
 В
списки $rez.preimages.0$ и $rez.preimages.1$ включены
индексы
прообразов
тройных
точек
и
точек
ветвления,
и
двойных
линий.
Индексы
соответствуют
клеткам
политопа $rez.manifold$.
Нумерация
внутри
списков $rez.images.i$ и $rez.preimages.i$ совпадает
в том
смысле,
что
прообразом
элемента $rez.images.i[k]$ являются
элементы
в
списке $rez.preimages.i[k]$.
Например,
прообраз
вершины
14,
которая
вляется
точкой
ветвления
являются
три
точки
в $rez.manifold$.
Вершина
11,
политопа $s3$ является
точкой
ветвления
в
диаграмме
2-узла,
для
нее мы
получим
ровно
одну
точку
в
прообразе,
политопе $rez.manifold$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@pos:=Position(rez.images.0,14);;|
  !gapprompt@gap>| !gapinput@rez.preimages.0[pos];|
  [ 82, 14, 81 ]
  !gapprompt@gap>| !gapinput@pos:=Position(rez.images.0,11);;|
  !gapprompt@gap>| !gapinput@rez.preimages.0[pos];          |
  [ 11 ]
  					
\end{Verbatim}
 И
наконец,
каждая
двойная
линия
имеет
ровно
два
прообраза. 

 Граф
сингулярных
точек
заузленной
поверности
состоит
из
набора
точек
соответствующих
тройным
точкам
и
точкам
ветвления,
при
этом
дуги
графа
могут
проходить
по
нескольким
ребрам
шарового
разбиения.
На
дугах
графа
двойных
точек
введена
произвольная
нумерация.
Список $rez.colines$ $i-$тому
двойному
ребру
из
списка $rez.images.1$ сопоставляет
дугу
графа
двойных
точек
которая
проходит
по
данному
ребру. 

 В $rez.cosheets$ для $i-$той
2-клетки
заузленной
поверхности
из
списка $s3.2knot$ указывает
какому
листу
разорванной
диаграммы
эта
2-клетка
принадлежит. 

 Так
как по
условиею
прообраз
заузленной
поверхности
является
ориентируемым
многообразием,
то
дуги
графа
двойных
точек
можно
ориентировать,
а так
же
присвоить
ориентации
вершинам
графа.
Направление
на
двойной
линии
является
положительными,
если
вместе
с
нормалями
верхнего
и
нижнего
листа
этой
линии,
выбранное
направление
составляет
положительный
репер.
Ориентация
тройной
точки
это
знак
репера
составленный
из
трех
исходящих
двойных
линий,
оринетация
точки
ветвления,
это
характеристика
входа
или
выхода
двойно
линии
из
данной
точки.
Эти
ориентации
содержатся
в
списках $rez.coorient.dim,$ где $dim=0$ или $1.$ Заметим,
что
оринетации
в $rez.coorient.1$ сопоставляются
не по
дугам
и по
двойным
ребрам,
то
есть
двойному
ребру
из $rez.images.1$ присваивается
такая
ориентация,
при
которой
его
направление
совпадало
бы с
направлением
на
дуге,
которой
он
принадлежит. 

 Список $rez.cofaces.0$ на $i-$том
месте
содержит
список
дуг
графа
двойных
точек
которые
содержат $i-$тую
вершину
графа.
Причем
если
вершина
является
тройной
точкой,
то
соответствующий
список
состоит
из
шести
элементов.
Первая
тройка
списка $rez.cofaces.0[i]$ это
дуги
входящие
в $i-$тую
тройную
точку,
оставшаяся
тройка
это
дуги
которые
исходят
из
указанной
вершины.
Причем
в
списках $rez.cofaces.0$ для
тройных
точек
введено
жесткое
упорядочение.
Первый
и
четвертый
элементы
списков,
это
верхние
линии,
второй
и
пятный
это
средние
линии,
и
оставшиеся,
третья
и
щестая
это
нижние
линии
в
данной
тройной
точке. 

 Список $rez.cofaces.1$ для
каждой
дуги
графа
двойных
точек
указывает
список
из
трех
элементов
в
которым
первым
указывается
номер
верхнего
листа,
вторым
индекс
нижнего
листа
по
направлению
нормали
нормали
верхнего
листа,
третьим
--
индекс
нижнего
листа
против
направления
номрали
верхенго
листа. }

 }

 }

 
\chapter{\textcolor{Chapter }{Структуры
рядом}}\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X7BE97DA57EB12CF8}{}
{
 
\section{\textcolor{Chapter }{Списки}}\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X844F0E76872E84E9}{}
{
 Следующие
списки
являются
полезными
при
работе
с
политопами. 

\subsection{\textcolor{Chapter }{ConnectedSubset}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X7E8931D08158230B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConnectedSubset({\mdseries\slshape lists})\index{ConnectedSubset@\texttt{ConnectedSubset}}
\label{ConnectedSubset}
}\hfill{\scriptsize (функция)}}\\


 Пусть
список
list
состоит
из
списков.
Функция
ConnectedSubset
выведет
все
индексы
внутренних
элементов,
которые
пересекаются
или
могут
быть
соединены
цепочкой
пересекающихся
элементов
с
первым
элементом
списка
lists. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@ConnectedSubset(T2.faces[1]);|
  [ 1, 4, 5, 8, 2, 6, 3, 7 ]
  					
\end{Verbatim}
 Наиболее
частое
применение
данная
функция
находит
в
разделении
на
связные
компоненты
многообразий,
отсюда
и
название
этой
функции. }

 

\subsection{\textcolor{Chapter }{SortCircle}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X81893FB17D432793}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SortCircle({\mdseries\slshape list})\index{SortCircle@\texttt{SortCircle}}
\label{SortCircle}
}\hfill{\scriptsize (функция)}}\\


 Входной
список
list
должен
состоять
из
двухэлементных
списков
которые
можно
рассматривать
как
ребра
графа.
Функция $SortCircle$ проведет
сортировку
списка $list$ исходя
из
предположения,
что
описываемый
им
граф
является
циклом. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@list:=T2.faces[1]{T2.faces[2][3]};|
  [ [ 2, 3 ], [ 1, 4 ], [ 1, 2 ], [ 3, 4 ] ]
  !gapprompt@gap>| !gapinput@SortCircle(list);|
  [ [ 2, 3 ], [ 1, 2 ], [ 1, 4 ], [ 3, 4 ] ]
  !gapprompt@gap>| !gapinput@list;|
  [  ]
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{LineOrdering}}
\logpage{[ 4, 1, 3 ]}\nobreak
\hyperdef{L}{X7906B3DC7F85CC27}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LineOrdering({\mdseries\slshape list})\index{LineOrdering@\texttt{LineOrdering}}
\label{LineOrdering}
}\hfill{\scriptsize (функция)}}\\


 Пусть
имеется
некоторое
разбиение
отрезка
на
интервалы,
которое
записано
в
список $list.$ Каждый
интервал
представлен
либо
парой
своих
элементов
-
концов
данного
интервала.
На
таком
множестве
можно
ввести
линейный
порядок.
Функция
возвращает
список
индексов,
который
задает
линейных
порядок
внутри
списка $list$ под
именем $.order$ и
ориентации
каждого
пары
под
именем $.orient.$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@list:=[ [ 2, 3 ], [ 4, 1 ], [ 2, 4 ], [ 15, 1 ], [ 15, 5 ] ];;|
  !gapprompt@gap>| !gapinput@LineOrdering(list);|
  rec( order := [ 5, 4, 2, 3, 1 ], orient := [ 1, -1, 1, -1, 1 ] )
  					
\end{Verbatim}
 Список
list может
представлять
из
себя
цикл. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@circ:=[[1,2],[3,4],[4,2],[1,3]];;|
  !gapprompt@gap>| !gapinput@LineOrdering(circ);|
  rec( order := [ 3, 1, 4, 2 ], orient := [ 1, -1, 1, 1 ] )
  					
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Рациональные
функции}}\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X7E0B26D57EB7AC25}{}
{
 Полином $f$ можно
разложить
на
множители $f = a f_1^{k_1} \dots f_n^{k_n}$. Это
дает
возможность
задать
функцию $f$ в
электронном
виде
более
экономично.
А
именно
функция
будет
записана
так [a, f{\textunderscore}1,
k{\textunderscore}1, ... , f{\textunderscore}n, k{\textunderscore}n].
Как
видно
первый
элемент
списка
является
коэффициентом
функции
при
старшей
степени,
затем
каждый
четный
элемент
списка
объявляет
множители
функции,
а
каждый
нечетный
кратности
множителей
стоящих
перед
ним.
Такую
запись
полинома
будем
называть
форматом
RatFunc. В
формате
RatFunc
рациональная
функция $r$ представляется
в виде
двухэлементного
списка.
Первый
и
второй
элементы
этого
списка
это
числитель
и
знаменатель
рациональной
функции $r$. Если
вместо
числителя(знаменателя)
стоит
пустое
множество,
считаем,
что
числитель(знаменатель)
равен
единице. 

\subsection{\textcolor{Chapter }{ConvertPolynomeToRatFunc}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X7C3E05D57A855C98}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConvertPolynomeToRatFunc({\mdseries\slshape f})\index{ConvertPolynomeToRatFunc@\texttt{ConvertPolynomeToRatFunc}}
\label{ConvertPolynomeToRatFunc}
}\hfill{\scriptsize (функция)}}\\


 преобразует
полином $f$ в
формат
RatFunc }

 

\subsection{\textcolor{Chapter }{ConvertToRatFunc}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X7A779D807C39FF10}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConvertToRatFunc({\mdseries\slshape f})\index{ConvertToRatFunc@\texttt{ConvertToRatFunc}}
\label{ConvertToRatFunc}
}\hfill{\scriptsize (функция)}}\\


 преобразует
рациональную
функцию $f$ в
формат
RatFunc. }

 

\subsection{\textcolor{Chapter }{ConvertFromRatFuncToPolynom}}
\logpage{[ 4, 2, 3 ]}\nobreak
\hyperdef{L}{X7F0A392F7EC34763}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConvertFromRatFuncToPolynom({\mdseries\slshape f})\index{ConvertFromRatFuncToPolynom@\texttt{ConvertFromRatFuncToPolynom}}
\label{ConvertFromRatFuncToPolynom}
}\hfill{\scriptsize (функция)}}\\


 преобразует
полином $f$ из
формата
RatFunc в
обычный
формат }

 

\subsection{\textcolor{Chapter }{ConvertFromRatFunc}}
\logpage{[ 4, 2, 4 ]}\nobreak
\hyperdef{L}{X7DF541D77AED60BA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConvertFromRatFunc({\mdseries\slshape f})\index{ConvertFromRatFunc@\texttt{ConvertFromRatFunc}}
\label{ConvertFromRatFunc}
}\hfill{\scriptsize (функция)}}\\


 преобразует
рациональную
функцию $f$ из
формата
RatFunc в
обычный
формат. }

 

\subsection{\textcolor{Chapter }{SimplifyRatFunc}}
\logpage{[ 4, 2, 5 ]}\nobreak
\hyperdef{L}{X85525EF3795860BC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SimplifyRatFunc({\mdseries\slshape f})\index{SimplifyRatFunc@\texttt{SimplifyRatFunc}}
\label{SimplifyRatFunc}
}\hfill{\scriptsize (функция)}}\\


 упрощение
рациональной
функции. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@f:=(x^2-y^2)/(x+y)^2;;|
  !gapprompt@gap>| !gapinput@f1:=ConvertToRatFunc(f);|
  [ [ 1, x-y, 1, x+y, 1 ], [ 1, x+y, 2 ] ]
  !gapprompt@gap>| !gapinput@SimplifyRatFunc(f1);|
  [ [ 1, x-y, 1 ], [ 1, x+y, 1 ] ]
  !gapprompt@gap>| !gapinput@g:=[[2,x-y^2,0],[]];;|
  !gapprompt@gap>| !gapinput@SimplifyRatFunc(g);|
  [ [ 2 ], [ 1 ] ]
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SumRatFunc}}
\logpage{[ 4, 2, 6 ]}\nobreak
\hyperdef{L}{X82E0B0FC7992BA2E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SumRatFunc({\mdseries\slshape f, g})\index{SumRatFunc@\texttt{SumRatFunc}}
\label{SumRatFunc}
}\hfill{\scriptsize (функция)}}\\


 Суммируем
рациональные
функции
заданные
в
формате
RatFunc }

 

\subsection{\textcolor{Chapter }{ProdRatFunc}}
\logpage{[ 4, 2, 7 ]}\nobreak
\hyperdef{L}{X7B1F22A07F55E140}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ProdRatFunc({\mdseries\slshape f, g})\index{ProdRatFunc@\texttt{ProdRatFunc}}
\label{ProdRatFunc}
}\hfill{\scriptsize (функция)}}\\


 функция
произведения
двух
рациональных
функций
формата
RatFunc }

 

\subsection{\textcolor{Chapter }{GcdPolynomial}}
\logpage{[ 4, 2, 8 ]}\nobreak
\hyperdef{L}{X8500B73B8429F14B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GcdPolynomial({\mdseries\slshape f, g})\index{GcdPolynomial@\texttt{GcdPolynomial}}
\label{GcdPolynomial}
}\hfill{\scriptsize (функция)}}\\


 вычисляется
наибольший
общий
делитель
полиномов $f$ и $g$.
Входящие
данные
могут
быть
как в
формате
RatFunc, так и в
виде
полиномов,
ответ
будет
создан
только
в
формате
RatFunc. 

 В
вычислении
наибольшего
общего
делителя
не
участвуют
коэффициенты
фукнций $f$ и $g$, их
следует
вычислять
отдельно. }

 

\subsection{\textcolor{Chapter }{LcmPolynomial}}
\logpage{[ 4, 2, 9 ]}\nobreak
\hyperdef{L}{X7CC8FF297DA9CF6B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LcmPolynomial({\mdseries\slshape f, g})\index{LcmPolynomial@\texttt{LcmPolynomial}}
\label{LcmPolynomial}
}\hfill{\scriptsize (функция)}}\\


 вычисляется
наименьшее
общее
кратное
полиномов $f$ и $g$.
Входящие
данные
могут
быть
как в
формате
RatFunc, так и в
виде
полиномов,
ответ
будет
создан
в
формате
RatFunc. 

 В
вычислении
наименьшего
общего
кратного
не
участвуют
коэффициенты
фукнций $f$ и $g$, их
следует
вычислять
отдельно. }

 

\subsection{\textcolor{Chapter }{DerivativePolynomRatFunc}}
\logpage{[ 4, 2, 10 ]}\nobreak
\hyperdef{L}{X81EA09AF878104FB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DerivativePolynomRatFunc({\mdseries\slshape f, x})\index{DerivativePolynomRatFunc@\texttt{DerivativePolynomRatFunc}}
\label{DerivativePolynomRatFunc}
}\hfill{\scriptsize (функция)}}\\


 вычисляется
производная
полинома
заданной
в
формате
RatFunc }

 

\subsection{\textcolor{Chapter }{DerivativeRatFunc}}
\logpage{[ 4, 2, 11 ]}\nobreak
\hyperdef{L}{X8112D91385A27DB0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DerivativeRatFunc({\mdseries\slshape f, x})\index{DerivativeRatFunc@\texttt{DerivativeRatFunc}}
\label{DerivativeRatFunc}
}\hfill{\scriptsize (функция)}}\\


 вычисляется
производная
рациональной
функции
заданной
в
формате
RatFunc }

 

\subsection{\textcolor{Chapter }{JacobiMatRatFunc}}
\logpage{[ 4, 2, 12 ]}\nobreak
\hyperdef{L}{X7F66B38A832B0FBD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{JacobiMatRatFunc({\mdseries\slshape listf, listx})\index{JacobiMatRatFunc@\texttt{JacobiMatRatFunc}}
\label{JacobiMatRatFunc}
}\hfill{\scriptsize (функция)}}\\


 Для
системы
рациональных
фукнций
listf
вычисляется
матрица
якоби
по
переменным
listx.
Формат
записи
данных
в
список
listf может
быть
смешанным,
то
есть в
список
могут
входить
как
обычные
функции,
так и
функции
заданные
в
формате
RatFunc. }

 }

 
\section{\textcolor{Chapter }{Матрицы}}\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X838E89737800BD8B}{}
{
 

\subsection{\textcolor{Chapter }{Pfaffian}}
\logpage{[ 4, 3, 1 ]}\nobreak
\hyperdef{L}{X7A4302F685FA84A8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Pfaffian({\mdseries\slshape mat})\index{Pfaffian@\texttt{Pfaffian}}
\label{Pfaffian}
}\hfill{\scriptsize (функция)}}\\


 Вычисляется
пфаффиан
кососимметирческой
матрицы $mat.$ Для
вычисления
используется
модифицированный
аналог
алгоритма
Гаусса. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@PrintArray(mat);|
  [ [   0,  -3,  -1,   1 ],
    [   3,   0,  -1,   2 ],
    [   1,   1,   0,   3 ],
    [  -1,  -2,  -3,   0 ] ]
  !gapprompt@gap>| !gapinput@Pfaffian(mat);|
  -8
  				
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Грассманнова
алгебра}}\logpage{[ 4, 4, 0 ]}
\hyperdef{L}{X7C77230C7AC163FF}{}
{
 На
данный
момент
не
реализовано
какой
либо
формальной
структуры
с
помощью
которой
можно
объявить
грассмановы
переменные
как
таковые.
Тем не
менее
для
задания
мономов
и
функций
на
грассмановых
переменных
используется
следующая
структура.
Предполагается,
что
грассмановы
переменные
нумерованы
и
любое
упорядочение
описываемое
ниже
является
лексикографическим,
если
не
оговорено
обратное.
Простой
моном
на
грассмановых
переменных
задается
как
двухэлементный
список
первым
элементом
которого
является
список
индексов
грассмановых
переменных
образующих
моном,
втором
коэффициент
этого
монома
над
некоторой
алгеброй
(полем).
Функция
на
грассмановых
переменных $f(x_1, x_2, \dots, x_k) = \sum a_{i_1, \ldots i_s} x_{i_1} \cdots x_{i_s}$ описывается
в как
именованный
список
с
двумя
полями
f.monomials и f.coeffs
которые
содержат
слово
из
грассмановых
переменных
и
коэффициент
данного
слова,
соответственно,
при
этом
коэффициент
f.coeffs[j]
принадлежит
слову
f.monomials[j]. 

\subsection{\textcolor{Chapter }{GrassmannMonomialsProduct}}
\logpage{[ 4, 4, 1 ]}\nobreak
\hyperdef{L}{X860AA41783165689}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GrassmannMonomialsProduct({\mdseries\slshape mon1, mon2})\index{GrassmannMonomialsProduct@\texttt{GrassmannMonomialsProduct}}
\label{GrassmannMonomialsProduct}
}\hfill{\scriptsize (функция)}}\\


 Вычисляется
произведение
двух
грассмановых
мономов.
Проиллюстрируем
функцию
на
следующих
примерах. $ (2\ a_1a_2) * (3\ a_5a_4a_6)=-6\ a_1a_2a_3a_4a_5 a_6$ и $(2\ a_1 a_2) * ( 3\ a_5 a_2 a_6) = 0.$ 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Пример]
  !gapprompt@gap>| !gapinput@GrassmannMonomialsProduct([[1,2],2],[[5,4,6],3]);|
  [ [ 1, 2, 4, 5, 6 ], -6 ]
  !gapprompt@gap>| !gapinput@GrassmannMonomialsProduct([[1,2],2],[[5,2,6],3]);|
  [ [  ], 0 ]
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{GrassmannProduct}}
\logpage{[ 4, 4, 2 ]}\nobreak
\hyperdef{L}{X7F3EE70681C3D8C0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GrassmannProduct({\mdseries\slshape f, g})\index{GrassmannProduct@\texttt{GrassmannProduct}}
\label{GrassmannProduct}
}\hfill{\scriptsize (функция)}}\\


 Произведение
грассмановых
функций $f$ и $g.$ }

 

\subsection{\textcolor{Chapter }{GrassmanSum}}
\logpage{[ 4, 4, 3 ]}\nobreak
\hyperdef{L}{X87E817917E35EBA6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GrassmanSum({\mdseries\slshape f, g})\index{GrassmanSum@\texttt{GrassmanSum}}
\label{GrassmanSum}
}\hfill{\scriptsize (функция)}}\\


 Сложение
грассманвых
функций $f$ и $g.$ }

 

\subsection{\textcolor{Chapter }{BerezinIntegral}}
\logpage{[ 4, 4, 4 ]}\nobreak
\hyperdef{L}{X80094E517830BE72}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BerezinIntegral({\mdseries\slshape f, a})\index{BerezinIntegral@\texttt{BerezinIntegral}}
\label{BerezinIntegral}
}\hfill{\scriptsize (функция)}}\\


 Вычисляется
интеграл
Березина
от
функции $f$ по
грассмановой
образующей $a$ (на
вход
функции
поступает
индекс
соответствующей
грассмановой
образующей). }

 

\subsection{\textcolor{Chapter }{BerezinMultipleIntegral}}
\logpage{[ 4, 4, 5 ]}\nobreak
\hyperdef{L}{X7A3ACABF7E9F9F6D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BerezinMultipleIntegral({\mdseries\slshape f, list})\index{BerezinMultipleIntegral@\texttt{BerezinMultipleIntegral}}
\label{BerezinMultipleIntegral}
}\hfill{\scriptsize (функция)}}\\


 Вычисляется
кратный
интеграл
Березина
от
функции $f$ по
некоторому
набору
грассмановых
переменных
указанных
в
списке $list.$ Порядок
следование
индексов
грассмановых
переменных
в
списке $list$ определяет
порядок
интегрирования. }

 }

 }

 \def\bibname{Ссылки\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X8728A4677F22C580}{}
}

\bibliographystyle{alpha}
\bibliography{PL-manual}

\addcontentsline{toc}{chapter}{Ссылки}

\def\indexname{Индекс\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X797DCB1687DCA32E}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Индекс}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
