<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (PL-manual) - Глава 3: Погружения и узлы</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Перейти к главе: </span><a href="chap0.html">Начало</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Начало книги]</a>&nbsp;  <a href="chap0.html#contents">[Содержание]</a>&nbsp;  &nbsp;<a href="chap2.html">[Предыдущая глава]</a>&nbsp;  &nbsp;<a href="chap4.html">[Следующая глава]</a>&nbsp;  </div>

<p><a id="X82CA5E1F7B3D3A5C" name="X82CA5E1F7B3D3A5C"></a></p>
<div class="ChapSects"><a href="chap3.html#X82CA5E1F7B3D3A5C">3 <span class="Heading">Погружения и узлы</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7EE9F2A87F05B455">3.1 <span class="Heading">Классические узлы</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D40248E7D685A1A">3.1-1 <span class="Heading">Способы задания диаграммы узла.</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7879B1EE80994B6E">3.1-2 Knot1OnSphere2</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A626B2A84CAD77E">3.1-3 KnotInS3</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D7395747EC32627">3.1-4 Reidemeister10Everywhere</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E710DED7C4E5B3A">3.1-5 ZeroLinkFromKnot</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8575EC5C7B564A45">3.1-6 ZeifertSurface</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D8D06467FBEB8CF">3.1-7 ZeifertSurfaceWithSimplyBoundary</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X8272DC908591F12A">3.2 <span class="Heading">Двумерные заузленные поверхности</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7BC82E957ADB11FC">3.2-1 <span class="Heading">Задание двумерных заузленных поверхностей</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X845EC0BA802775BB">3.2-2 PolSimplifyWith2Knot</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X859D50D9858D5B25">3.2-3 SingularitySet2Knot</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81D8934B80A7BE6A">3.2-4 TripleDoubleBranchPoints</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X85C517DC8068D8EF">3.2-5 IsDiagrammOf2Kont</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7916ADAB7B29E1E7">3.2-6 Preimage2Knot</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X857BA8697BA2F587">3.2-7 TurnKnot</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X848FEA1F80CF0734">3.2-8 2KnotInS4</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Погружения и узлы</span></h3>

<p>Пакет <span class="SimpleMath">PL</span> предоставляет возможность работы с одномерными узлами и двумерными заузленными поверхностями.</p>

<p><a id="X7EE9F2A87F05B455" name="X7EE9F2A87F05B455"></a></p>

<h4>3.1 <span class="Heading">Классические узлы</span></h4>

<p>В пакете PL имеется возможность задания диаграммы узла двумя различными способами каждый из которых имеет свои плюсы и свои минусы.</p>

<p><a id="X7D40248E7D685A1A" name="X7D40248E7D685A1A"></a></p>

<h5>3.1-1 <span class="Heading">Способы задания диаграммы узла.</span></h5>

<p>Первый способ основан на том, что диаграмме узла сопоставляются атрибуты которые однозначно характеризуют диаграмму. Для этого присвоим имена каждой двойной точке, которые назовем образующими и выберем на узле произвольным образом начальную точку и положительное направление, причем диаграмму можно построить так, что бы отмеченная точка не стала при проекции двойной точкой. При обходе диаграммы начиная от отмеченной точки по выбранному направлению можно составить слово по следующему правилу: на начальном этапе имеем пустое слово, далее каждая встреченная двойная точка приписывается к слову справа в степени <span class="SimpleMath">-1</span> если мы пришли в эту точку снизу и в степени <span class="SimpleMath">1</span> если пришли сверху. Когда мы вернемся в начальную точку, создание слова заканчивается. Дополнительно, каждая двойная точка имеет свою ориентацию которую образует выбранное нами направление. Ориентацию двойной точки предлагается строить так. В двойной точке строится два вектора <span class="SimpleMath">v_1</span> и <span class="SimpleMath">v_2,</span> где <span class="SimpleMath">v_1</span> --- касательный вектор к верхней дуге диаграммы на плоскости, <span class="SimpleMath">v_2</span> --- к нижней. В качестве ориентации этой точки выбирается знак построенного репера. Воспользуемся данным описанием и составим необходимые атрибуты для задания узла трилистника. Для трилистника будет составлено слово <span class="SimpleMath">ac^-1ba^-1cb^-1</span> и для каждой двойной точки диаграммы каждая двойная точка этой диаграммы имеет отрицательную ориентацию. Если данные ориентации заменить на противоположные, то будет создана зеркальная диаграмма к указанной. Ниже представлена диаграмма узла трилистника включенная в библиотеку пакета <span class="SimpleMath">PL.</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Trefoil;</span>
rec( kod := [ [ "a", 1 ], [ "c", -1 ], [ "b", 1 ],
              [ "a", -1 ], [ "c", 1 ], [ "b", -1 ] ],
     orient := [ [ "a", -1 ], [ "b", -1 ], [ "c", -1 ] ] )
  				</pre></div>

<p>Как видно из примера вся необходимая информация собрана в списках .kod и .orient. Слово которое составляется при обходе узла представлено списком .kod который содержит двухэлементные списки, первым элементом которого является имя двойной точки, вторым <span class="SimpleMath">± 1</span> в зависимости от степени соответствующей образующей в слове. Сравните слово <span class="SimpleMath">ac^-1ba^-1cb^-1</span> составленное по трилистнику со списком Trefoil.kod. Далее, список .orient составлен из списка пар, первый элемент пары --- имя двойной точки, второй ориентация. Задание таким образом зацеплений несколько усложняется тем, что необходимо отдельно указывать компоненты зацепления. В случае, если стоит необходимость вручную задать диаграмму обычного узла данный способ является лучшим поскольку информация легко проверяется. Предполагается, что данная диаграмма лежит на двумерной плоскости, отсюда мы будем называть этот способ задания -- плоским, что бы различать два способа описания диаграмм узлов. Второй способ задания диаграммы узла основан на той идее, что диаграмма узла естественным образом создает разбиение двумерной плоскости, а следовательно аналогичное разбиение можно выбрать и на сфере <span class="SimpleMath">S^2</span> после одноточечной компактификации. Отсюда, для удобства, этот способ далее будем называть сферическим. Итак, этот способ описания диаграммы заключается в создании такого шарового разбиения двумерной сферы по клеткам которого проходят дуги диаграммы узла. То есть дополнительно к <span class="SimpleMath">pl-</span>разбиению присоединяется информация о дугах диаграммы узла и о том как ведут себя дуги в районе двойной точки. В случае классических узлов достаточно указать все 1-клетки по которым проходят клетки узла. Двойные точки вычисляются уже из представленной информации, но для каждой двойной точки необходимо знать какая дуга выше, какая ниже.</p>


<div class="example"><pre>
rec(
  1knot :=
    rec(
      dpoints := rec( 1 := [ 6, 1, 3, 4 ], 2 := [ 2, 3, 5, 6 ],
          3 := [ 4, 5, 1, 2 ] ), sheets := [ 1 .. 6 ] ),
  faces := [ [ [ 1, 3 ], [ 2, 3 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2 ] ],
      [ [ 1, 3, 5 ], [ 1, 4 ], [ 2, 4, 6 ], [ 2, 5 ], [ 3, 6 ] ] ],
  vertices := [ "a", "b", "c" ] )
			</pre></div>

<p>В данном примере приведена диаграмма узла трилистника расположенная на двумерной сфере. Сначала, обратим внимание, что вся информация касающаяся узла помещена в именованный список .1knot, в котором содержатся списки .sheets всех 1-клеток <span class="SimpleMath">pl-</span>разбиения по которому проходит диаграмма и .dpoints который в качестве именованных полей содержит индексы вершин, а в качестве соответствующих объектов списки из четырех элементов в которых первая пара элементов это индексы 1-клеток входящих в верхнюю дугу диаграммы в этой точке, последняя пара --- индексы 1-клеток входящих в нижнюю дугу диаграммы в данной точке. Данная конструкция неудобна для описания ее напрямую по диаграмме узла поскольку содержит излишнюю информацию, но с другой стороны предложенный способ обладает двумя преимуществами. Во-первых, это задание может напрямую работать с диаграммами зацеплений узлов. Во-вторых, такое задание легко обобщается на двумерные заузленные поверхности, о чем будет рассказано ниже.</p>

<p><a id="X7879B1EE80994B6E" name="X7879B1EE80994B6E"></a></p>

<h5>3.1-2 Knot1OnSphere2</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Knot1OnSphere2</code>( <var class="Arg">knot</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>по диаграмме узла создается двумерная сфера <span class="SimpleMath">S^2,</span> в разбиении которой указана данная диаграмма. Узел содержится в прикрепленном именованном списке .1knot, который построен в стиле задания диаграмм двумерных заузленных поверхностей.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Knot1OnSphere2(Figure8);</span>
rec(
  1knot :=
    rec(
      dpoints := rec( 1 := [ 8, 1, 4, 3 ], 2 := [ 4, 5, 8, 7 ],
          3 := [ 2, 3, 5, 6 ], 4 := [ 6, 7, 1, 2 ] ), sheets := [ 1 .. 8 ] ),
  faces :=
    [ [ [ 1, 4 ], [ 3, 4 ], [ 1, 3 ], [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 2, 4 ],
          [ 1, 2 ] ],
      [ [ 1, 3, 6 ], [ 1, 4, 7 ], [ 2, 5, 7 ], [ 2, 6 ], [ 3, 5, 8 ], [ 4, 8 ]
         ] ], vertices := [ "a", "b", "c", "d" ] )
		</pre></div>

<p><a id="X7A626B2A84CAD77E" name="X7A626B2A84CAD77E"></a></p>

<h5>3.1-3 KnotInS3</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KnotInS3</code>( <var class="Arg">knot</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Создает трехмерную сферу в которую вложен узел. Клетки узла указаны в result.knot.</p>

<p><a id="X7D7395747EC32627" name="X7D7395747EC32627"></a></p>

<h5>3.1-4 Reidemeister10Everywhere</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Reidemeister10Everywhere</code>( <var class="Arg">knot</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Проверяет диаграмму узла на наличие в ней свободных петель, которые можно убрать первым движением Райдемайстера <span class="SimpleMath">R^-1_0.</span> Число <span class="SimpleMath">10</span> в названии обозначает, что применяется движение Райдемайстера, которое берет локально одну вершину и создает из него ноль вершин, если такое движение применимо.</p>

<p><a id="X7E710DED7C4E5B3A" name="X7E710DED7C4E5B3A"></a></p>

<h5>3.1-5 ZeroLinkFromKnot</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ZeroLinkFromKnot</code>( <var class="Arg">knot</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Не изменяя самого узла, данная функция создает такую диаграмму, которая будет иметь нулевой коэффициент зацепления с диаграммой составленной следующим образом. Для узла создается трубчатая окрестность в трехмерном пространстве. Проекция узла параллельно оси <span class="SimpleMath">Oz</span> на трубчатую окрестность создает новый узел (по сути дела тот же самый). Два узла созданных по предложенной диаграмме образуют зацепление с нулевым коэффициентом.</p>

<p><a id="X8575EC5C7B564A45" name="X8575EC5C7B564A45"></a></p>

<h5>3.1-6 ZeifertSurface</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ZeifertSurface</code>( <var class="Arg">knot</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>создает поверхность Зейферта узла, вложенную в трехмерную сферу. Все 2-клетки отвечающие поверхности Зейферта собраны в списке .zeifert прикрепленному к политопу.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pol:=ZeifertSurface(Knot7_7);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">zeif:=SubPolytope(pol, pol.zeifert, 2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolOrient(zeif);</span>
[ 1, 1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, 1 ]
					</pre></div>

<p>В данном примере мы создали сферу с указанной в ней поверхностью Зейферта, выделили ее как самостоятельный политоп и проверили является ли эта поверхность ориентируемой. Тем самым мы проиллюстрировали ориентируемость полученного объекта.</p>

<p><a id="X7D8D06467FBEB8CF" name="X7D8D06467FBEB8CF"></a></p>

<h5>3.1-7 ZeifertSurfaceWithSimplyBoundary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ZeifertSurfaceWithSimplyBoundary</code>( <var class="Arg">knot</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>создает поверхность Зейферта узла <span class="SimpleMath">knot,</span> чья граница состоит только из двух 1-клеток (соответственно по которым и проходит сам узел).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pol:=ZeifertSurfaceWithSimplyBoundary(Knot7_7);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfFacesBoundary(pol,pol.zeifert,2);</span>
[ 49, 159 ]
				</pre></div>

<p><a id="X8272DC908591F12A" name="X8272DC908591F12A"></a></p>

<h4>3.2 <span class="Heading">Двумерные заузленные поверхности</span></h4>

<p>Под заузленной двумерной поверхностью (surface-knot) мы понимаем связную или не связную поверхность помещенную в четырехмерное евклидово пространство <span class="SimpleMath">R^4.</span> Проекция <span class="SimpleMath">π : R^4 -&gt; R^3</span> общая (is generic) для заузленной поверхности <span class="SimpleMath">T</span> если если образ <span class="SimpleMath">π (T)</span> из <span class="SimpleMath">R^3</span> локально гомеоморфен 1) простому диску 2) двум трансверсально пересекающимся дискам 3) трем трансверсально пересекающимся дискам или 4) зонтику Уитни. Точки имеющие окрестности с 2) по 4) называются двойными точкаи, тройными точками и точками ветвления общей проекции, соответственно. Множество всех точек типа 2),3) и 4) называется графом двойных точек (singularity set). Диаграммой поверхности <span class="SimpleMath">T</span> называют образ <span class="SimpleMath">π (T)</span> с добавлением информации пересечения на графе двойных точек. Для каждой лини двойных точек должно быть определено отношение высот для листов которые входят в это ребро.</p>

<p><a id="X7BC82E957ADB11FC" name="X7BC82E957ADB11FC"></a></p>

<h5>3.2-1 <span class="Heading">Задание двумерных заузленных поверхностей</span></h5>

<p>Аналогично одномерным узлам, диаграммы двумерных заузленных поверхностей могут быть рассмотрены уже внутри разбиения трехмерной сферы <span class="SimpleMath">S^3.</span> В качестве такой диаграммы мы понимает шаровое разбиение трехмерной сферы по клеткам которой проходят листы двумерной заузленной поверхности. Вся информация о диаграмме внутри политопа собирается в прикрепленном именованном списке .2knot. Список .2knot содержит список .sheets в котором собраны индексы всех 2-клеток шарового разбиения по которым проходит диаграмма заузленной поверхности и именованный список .dpoints в котором именами выступают ребра двойных точек. В списке .2knot.dpoints каждому двойному ребру поставлен в соответствие четырехэлементный список индексов 2-клеток диаграммы лежащих в звезде данного двойного ребра. На четрыхэлементном списке выбрано следующее упорядочение, первые два индекса соответствуют 2-клеткам в звезде ребра лежащие на верхнем листе, последние два это индексы 2-клеток на нижнем. Данной информации о диаграмме двумерной заузленной поверхности достаточно чтобы вычислить тройные точки и точки ветвления. Внутри программ мы не будем проводить четкого разделения между двумерными заузленными поверхностями и двумерными узлами. Вся информация о данных структурах будет собираться в прикрепленном списке .2knot.</p>

<p><a id="X845EC0BA802775BB" name="X845EC0BA802775BB"></a></p>

<h5>3.2-2 PolSimplifyWith2Knot</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolSimplifyWith2Knot</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>упрощает политоп содержащий 2-узел. В качестве упрощающей функции была выбрана функция UnionFaces, которая объединяет два шара в политопе. Так же как и функция PolSimplify данная функция не проверяет возможны ли дальнейшие упрощение политопа <span class="SimpleMath">pol.</span> Для этой проверки необходимо еще раз запустить эту функцию на вновь полученных данных.</p>


<div class="example"><pre>
  	
  	</pre></div>

<p><a id="X859D50D9858D5B25" name="X859D50D9858D5B25"></a></p>

<h5>3.2-3 SingularitySet2Knot</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SingularitySet2Knot</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Singularity set --- граф двойных точек диаграммы 2-узла. В графе перечислены все 1-клетки объемлющего политопа <span class="SimpleMath">pol</span> которые содеражт описываемый граф. Так же в соответствии каждой вершине сопоставлен список. Данный список строится из звезды <span class="SimpleMath">Star(v)</span> в описываемом графе упорядоченной таким образом. Первая пара элементов принадлежит верхней линии двойных точек в этой вершине (получаемая на пересечении верхнего и среднего листов), вторая пара элементов принадлежит средней линии двойных точек (пересечение верхнего и нижнего листов) и третья пара принадлежит нижней линии двойных точек (пересечение среднего и нижнего листов). Таким образом соответсвующие списки для тройной точки будут состоять из шести элементов, для двойной точки из двух и для точки ветвления из одного.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SingularitySet2Knot(TurnKnot(Trefoil,2));</span>
	...
rec( graf := [ 7, 4, 5, 6, 19, 20, 21, 22, 17, 18, 23, 8, 9, 10, 12, 45, 32,
      31, 25, 26, 51, 54, 55, 64, 112, 113, 114, 115, 134, 136, 137, 138,
      131, 130, 129, 119, 109, 118, 127, 106, 124, 105, 123, 104, 122, 102,
      99, 98, 79, 97, 78, 53, 94, 52, 59, 93, 92, 57, 73, 56, 72, 90, 70, 69,
      68, 67, 66, 65 ],
  order := rec( 1 := [ 137, 92 ], 10 := [ 12, 102 ], 11 := [ 10, 12 ],
      13 := [ 4 ], 14 := [ 22, 17, 19, 20, 104, 97 ],
      15 := [ 19, 18, 21, 22, 105, 98 ], 16 := [ 20, 21, 18, 23, 106, 99 ],
      19 := [ 25 ], 2 := [ 138, 94 ], 20 := [ 32, 31, 25, 26, 109, 102 ],
      21 := [ 23, 26 ], 23 := [ 17, 32 ], 24 := [ 31, 112 ],
      25 := [ 113, 104 ], 26 := [ 114, 105 ], 27 := [ 115, 106 ],
      30 := [ 45, 109 ], 34 := [ 45, 112 ], 36 := [ 113, 118 ],
      37 := [ 115, 119 ], 40 := [ 51, 56, 54, 53, 118, 122 ],
      41 := [ 53, 52, 55, 56, 114, 123 ], 42 := [ 54, 55, 52, 57, 119, 124 ],
      45 := [ 127, 59 ], 46 := [ 59, 57 ], 48 := [ 51 ],
      49 := [ 64, 69, 67, 66, 129, 122 ], 5 := [ 4, 9, 7, 6, 97, 92 ],
      50 := [ 66, 65, 69, 68, 130, 123 ], 51 := [ 68, 67, 70, 65, 131, 124 ],
      54 := [ 72 ], 55 := [ 79, 78, 73, 72, 134, 127 ], 56 := [ 73, 70 ],
      58 := [ 64, 79 ], 59 := [ 136, 78 ], 6 := [ 5, 6, 8, 9, 98, 93 ],
      60 := [ 137, 129 ], 61 := [ 130, 93 ], 62 := [ 138, 131 ],
      64 := [ 134, 90 ], 67 := [ 136, 90 ], 7 := [ 7, 8, 5, 10, 99, 94 ] ) )
  	</pre></div>

<p><a id="X81D8934B80A7BE6A" name="X81D8934B80A7BE6A"></a></p>

<h5>3.2-4 TripleDoubleBranchPoints</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TripleDoubleBranchPoints</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Для шарового разбиения многообразия, внутри которого указана диаграмма заузленной поверхнсоти вычисляются те вершины политопа, которые являются тройными точками, двойными точками или точками ветвления. По возможности для каждой точки указываются 2-клетки диаграммы группированные по принадлежности различным листам. Функция выводит именованный список с полями .triple, .double и .branch. В именованном списке result.triple каждой вершине <span class="SimpleMath">v</span> под списком поля .u можно узнать 2-клетки звезды на верхнем листе в тройной точке <span class="SimpleMath">v</span>, под списком .m --- 2-клетки на среднем листе и под списком .d --- на нижнем. Для двойной точки указываются только списки .u и .d. Для точки ветвления указан только список 2-клеток узла лежащих в звезде этой вершины.</p>


<div class="example"><pre>
 gap&gt; pol:=TurnKnot(Trefoil,1);;
 ...
 gap&gt; TripleDoubleBranchPoints(pol);
rec( branch := rec( 13 := [ 2, 6, 22, 30 ], 19 := [ 13, 16, 37, 44 ] ),
  double :=
    rec( 1 := rec( d := [ 24, 25, 41, 57 ], u := [ 22, 57, 51, 27 ] ),
      10 := rec( d := [ 28, 37, 38 ], u := [ 2, 30, 7 ] ),
      11 := rec( d := [ 28, 36, 38 ], u := [ 2, 6, 7 ] ),
      2 := rec( d := [ 23, 28, 55, 52, 55 ], u := [ 25, 41, 26 ] ),
      21 := rec( d := [ 36, 38, 43 ], u := [ 8, 12, 14 ] ),
      23 := rec( d := [ 30, 39, 48 ], u := [ 8, 12, 16 ] ),
      24 := rec( d := [ 7, 46, 47 ], u := [ 13, 44, 14 ] ),
      25 := rec( d := [ 24, 40, 41 ], u := [ 27, 39, 51 ] ),
      26 := rec( d := [ 26, 42, 27 ], u := [ 23, 24, 40 ] ),
      27 := rec( d := [ 23, 43, 52 ], u := [ 26, 42, 41 ] ),
      30 := rec( d := [ 47, 48, 51, 57 ], u := [ 19, 44, 20, 43 ] ),
      34 := rec( d := [ 46, 54, 57, 47 ], u := [ 14, 20, 19, 44 ] ) ),
  triple :=
    rec(
      14 := rec( d := [ 32, 33, 40, 41 ], m := [ 27, 30, 35, 39 ],
          u := [ 8, 9, 11, 12 ] ),
      15 := rec( d := [ 27, 34, 35, 42 ], m := [ 23, 31, 32, 40 ],
          u := [ 9, 10, 11, 12 ] ),
      16 := rec( d := [ 23, 31, 36, 43 ], m := [ 33, 34, 41, 42 ],
          u := [ 8, 9, 10, 12 ] ),
      20 := rec( d := [ 37, 38, 43, 44 ], m := [ 7, 30, 47, 48 ],
          u := [ 8, 13, 14, 16 ] ),
      5 := rec( d := [ 24, 25, 32, 33 ], m := [ 22, 27, 30, 35 ],
          u := [ 2, 3, 5, 6 ] ),
      6 := rec( d := [ 26, 27, 34, 35 ], m := [ 23, 24, 31, 32 ],
          u := [ 3, 4, 5, 6 ] ),
      7 := rec( d := [ 23, 28, 31, 36 ], m := [ 25, 26, 33, 34 ],
          u := [ 2, 3, 4, 6 ] ) ) )
		</pre></div>

<p><a id="X85C517DC8068D8EF" name="X85C517DC8068D8EF"></a></p>

<h5>3.2-5 IsDiagrammOf2Kont</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDiagrammOf2Kont</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Проверяет диаграмму 2-узла вложенную в трехмерное многообразие. Для этого проверяются: 1) корректность всех ссылок на клетки политопа, 2) граф двойных точек, 3) отсутствие точек самокасания.</p>


<div class="example"><pre>
 gap&gt; pol:=TurnKnot(Figure8,-1);;

  All good!

 gap&gt; IsDiagrammOf2Kont(pol);
 true
		</pre></div>

<p><a id="X7916ADAB7B29E1E7" name="X7916ADAB7B29E1E7"></a></p>

<h5>3.2-6 Preimage2Knot</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Preimage2Knot</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Построение прообраза заузленной поверхности по диаграмме.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pol:=TurnKnot(Trefoil,0);;</span>
 ...
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sp:=Preimage2Knot(pol);</span>
rec(
  faces :=
    [ [ [ 2, 3 ], [ 2, 7 ], [ 7, 9 ], [ 8, 9 ], [ 1, 8 ], [ 5, 6 ], [ 5, 10 ],
          [ 10, 12 ], [ 11, 12 ], [ 4, 11 ], [ 7, 10 ], [ 8, 11 ], [ 3, 6 ],
          [ 7, 10 ], [ 8, 11 ], [ 3, 6 ], [ 9, 12 ], [ 2, 5 ], [ 9, 12 ],
          [ 1, 4 ], [ 1, 4 ], [ 2, 5 ] ],
      [ [ 20, 21 ], [ 1, 6, 13, 22 ], [ 2, 7, 11, 22 ], [ 3, 8, 11, 17 ],
          [ 4, 9, 12, 17 ], [ 5, 10, 12, 20 ], [ 13, 16 ], [ 1, 6, 16, 18 ],
          [ 2, 7, 14, 18 ], [ 3, 8, 14, 19 ], [ 4, 9, 15, 19 ],
          [ 5, 10, 15, 21 ] ] ],
  vertices := [ [ 1, "a" ], [ 1, "b" ], [ 1, "c" ], [ 2, "a" ], [ 2, "b" ],
      [ 2, "c" ], 7, 8, 9, 10, 11, 12 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolSimplify(sp);</span>
...
rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ] ],
  vertices := [ [ 1, "a" ], [ 1, "b" ] ] )
		</pre></div>

<p><a id="X857BA8697BA2F587" name="X857BA8697BA2F587"></a></p>

<h5>3.2-7 TurnKnot</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TurnKnot</code>( <var class="Arg">knot</var>, <var class="Arg">number</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>создается диаграмма 2-узла вложенная в трехмерную сферу <span class="SimpleMath">S^3</span> с помощью алгоритма SpunTwist на основании диаграммы одномерного узла <span class="SimpleMath">knot</span>. Число <span class="SimpleMath">number</span> задает количество оборотов данной диаграммы при осуществлении twist-движения, при этом отрицательный знак данного числа задает обращение узла в противоположном направлении, при этом если <span class="SimpleMath">number</span> указать равным нулю, тогда twist-оборотов в диаграмме не будет и мы получим простую spun-диаграмму.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TurnKnot(Trefoil,0);</span>
I'm trying simplify a polytope.

  ...

 All good!

rec(
  2knot :=
    rec( dpoints := rec( 11 := [ 12, 7, 9, 10 ], 12 := [ 8, 9, 11, 12 ],
          13 := [ 10, 11, 13, 8 ], 14 := [ 18, 7, 15, 16 ],
          15 := [ 14, 15, 17, 18 ], 16 := [ 16, 17, 13, 14 ] ),
      sheets := [ 7, 8, 14, 9, 15, 10, 16, 11, 17, 12, 18, 13 ] ),
  faces :=
    [ [ [ 2, 3 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2 ], [ 5, 6 ], [ 4, 5 ],
          [ 4, 6 ], [ 5, 6 ], [ 4, 5 ], [ 1, 4 ], [ 2, 5 ], [ 3, 6 ],
          [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ],
      [ [ 1, 3, 5 ], [ 1, 4 ], [ 2, 5 ], [ 6, 8, 10 ], [ 6, 9 ], [ 7, 10 ],
          [ 11, 14 ], [ 1, 6, 12, 13 ], [ 2, 7, 11, 12 ], [ 3, 8, 11, 13 ],
          [ 4, 9, 12, 13 ], [ 5, 10, 11, 12 ], [ 13, 16 ], [ 1, 6, 15, 16 ],
          [ 2, 7, 14, 15 ], [ 3, 8, 14, 16 ], [ 4, 9, 15, 16 ],
          [ 5, 10, 14, 15 ] ],
      [ [ 7, 10, 13, 16 ], [ 1, 4, 8, 10, 12 ], [ 2, 5, 8, 11 ],
          [ 3, 6, 9, 12 ], [ 1, 4, 14, 16, 18 ], [ 2, 5, 14, 17 ],
          [ 3, 6, 15, 18 ] ] ],
  vertices := [ [ 1, "a" ], [ 1, "b" ], [ 1, "c" ], [ 2, "a" ], [ 2, "b" ],
      [ 2, "c" ] ] )
		</pre></div>

<p><a id="X848FEA1F80CF0734" name="X848FEA1F80CF0734"></a></p>

<h5>3.2-8 2KnotInS4</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; 2KnotInS4</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>По трехмерному политопу <span class="SimpleMath">pol</span> в котором содержится диаграмма заузленной двумерной поверхности <span class="SimpleMath">T</span> создается вложение этой поверхности <span class="SimpleMath">T</span> в четырехмерную сферу <span class="SimpleMath">S^4.</span></p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Начало книги]</a>&nbsp;  <a href="chap0.html#contents">[Содержание]</a>&nbsp;  &nbsp;<a href="chap2.html">[Предыдущая глава]</a>&nbsp;  &nbsp;<a href="chap4.html">[Следующая глава]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Перейти к главе: </span><a href="chap0.html">Начало</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
