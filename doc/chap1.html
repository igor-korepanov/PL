<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (PL-manual) - Глава 1: Шаровые комплексы.</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Перейти к главе: </span><a href="chap0.html">Начало</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Начало книги]</a>&nbsp;  <a href="chap0.html#contents">[Содержание]</a>&nbsp;  &nbsp;<a href="chap0.html">[Предыдущая глава]</a>&nbsp;  &nbsp;<a href="chap2.html">[Следующая глава]</a>&nbsp;  </div>

<p><a id="X83577E337970576A" name="X83577E337970576A"></a></p>
<div class="ChapSects"><a href="chap1.html#X83577E337970576A">1 <span class="Heading">Шаровые комплексы.</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7A57CB8E853465BB">1.1 <span class="Heading">Representation of a PL ball complex</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X81EA74AA7B4B6DDB">1.1-1 IsPolytope</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7DC1CA798242AF10">1.2 <span class="Heading">Укзывающие функции</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7E2C717A7CE81114">1.2-1 FundGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X815EDAEB7BDC2E6F">1.3 <span class="Heading">Общая информация о шаровом комлпексе</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7826D40B82C44A08">1.3-1 PolBoundary</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7DF0C625871788B7">1.3-2 PolInnerFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7DDF02FE8581EF3D">1.3-3 MaxTree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X82CF2896859B26C6">1.3-4 CellOrient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A1EAA26847A1C43">1.3-5 PolOrient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X81AE197083B0A56A">1.3-6 OrientTriangulated</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X83986ED47DDF8E20">1.3-7 dataPachner</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X873915C482448F75">1.3-8 FromSimplexToPolytope</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X860B263684CFACF7">1.4 <span class="Heading">Работа с клетками</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7AB8BF4E7E72C22D">1.4-1 PolBnd</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7B4C20C784524379">1.4-2 FaceComp</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7E4697E984788243">1.4-3 StarFace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7BBC530C857D247E">1.4-4 PolCheckComb</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X79A0EF12877971D1">1.5 <span class="Heading">Изменение <span class="SimpleMath">pl-</span>разбиения (не изменющие)</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X79EBAEC68713D5FE">1.5-1 PolTriangulate</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7DE97F0184E8F0BE">1.5-2 FirstBoundary</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X863CAD14822179DC">1.5-3 PermFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X844FBAF17BC1B42B">1.5-4 ContractMiniFace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7AF2A3E286F2E10F">1.5-5 DivideFace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X863829C97B6FAAA0">1.5-6 PolSimplify1</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7A0D373E78BB66A0">1.6 <span class="Heading">Непосредственное создание политопов</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X83EC07DE83EC07DE">1.6-1 ballAB</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X791C9DFE87250DEF">1.6-2 sphereAB</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X82DB526A7F364516">1.6-3 ballTriangul</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X80EEACD2781E40F7">1.6-4 sphereTriangul</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7CC221C778D0F16A">1.7 <span class="Heading">Топологические операции</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X833B125E832EA5F5">1.7-1 FreeUnionPol</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X827171907A7228C4">1.7-2 PolCylinder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X813B0AA1829E736E">1.7-3 PolDoubleCone</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A9E18837F637D8D">1.7-4 PolProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7F0929CD82A0CE28">1.7-5 ImageInPolProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A32AE2D8733963A">1.7-6 PolProductSyms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7B4164647D6C5EC6">1.7-7 PolProductSymsDict</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A3091A38613DA64">1.7-8 PolFactorInvolution</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7C78FB387A55C8AB">1.8 <span class="Heading">Основные принцыпы перестроек шаровых комплексов</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7F4B33CD85588148">1.8-1 DelFace</a></span>
</div></div>
</div>

<h3>1 <span class="Heading">Шаровые комплексы.</span></h3>

<p>Piecewise-linear, or simply PL, ball complexes are, at least at this moment, the central objects with which our package <span class="SimpleMath">PL</span> deals. First, a ball complex is, simply speaking, a kind of cell complex but such where all <em>closed</em> cells ( = balls) are <em>embedded</em>. In particular, their boundaries are genuine spheres, not crumpled/folded. The formal definition of <span class="SimpleMath">PL</span> ball complex reads: A PL ball complex is a pair <span class="SimpleMath">(X, U)</span>, where <span class="SimpleMath">X</span> is a compact Euclidean polyhedron and <span class="SimpleMath">U</span> is a covering of <span class="SimpleMath">X</span> by closed PL-balls such that the following axioms are satisfied:</p>


<ul>
<li><p>the relative interiors of balls from <span class="SimpleMath">U</span> form a partition of <span class="SimpleMath">X</span>,</p>

</li>
<li><p>the boundary of each ball from <span class="SimpleMath">U</span> is a union of balls from <span class="SimpleMath">U</span>.</p>

</li>
</ul>
<p>We also call PL ball complexes ``polytopes'', for brevity, hence prefix ``Pol'' in the names of some of our functions.</p>

<p><a id="X7A57CB8E853465BB" name="X7A57CB8E853465BB"></a></p>

<h4>1.1 <span class="Heading">Representation of a PL ball complex</span></h4>

<p>A <span class="SimpleMath">PL</span>-ball complex is defined up to <span class="SimpleMath">PL</span>-homeomorphism only by the combinatorics of adjunctions of its balls. Due to this, we represent them combinatorially in the following way. First, we assume that all vertices in the complex are numbered from 1 to their total number <span class="SimpleMath">N_0</span>. Hence, in this sense, the 0-skeleton of the complex is described. Next, assuming that the <span class="SimpleMath">k</span>-skeleton is already given, which implies (in particular) the numeration of all <span class="SimpleMath">k</span>-cells, we describe the <span class="SimpleMath">(k+1)</span>-skeleton as the list of all <span class="SimpleMath">(k+1)</span>-cells, each of which, in its turn, is the set of numbers of <span class="SimpleMath">k</span>-cells in its boundary. Then we compose the list of length <span class="SimpleMath">n</span>, where <span class="SimpleMath">n</span> is the dimension of the complex, whose elements are lists of 1-,..., <span class="SimpleMath">n</span>-cells. Thus, a three-dimensional ball <span class="SimpleMath">B^3</span> can be represented by the following <span class="SimpleMath">PL</span> ball complex with two vertices 1 and 2:</p>


<div class="example"><pre>

  [ [1,2], [1,2] ], # two one-dimensional simplexes, each with
                    # ends 1 and 2, of which the first is referred to
                    # in the next line as 1, the second - as 2;
  [ [1,2], [1,2] ], # two disks - bigons - bounded each by
                    # one-dimensional simplexes 1 and 2;
  [ [1,2] ]         # the three-ball bounded by bigons 1 and 2
]
			</pre></div>

<p>ТУТ БЫ НАДО ВСТАВИТЬ КАРТИНКУ Actually, we add a list of vertices with their names or something like that in the beginning of the above ball complex representation. For instance, our function <code class="code">ballAB</code><span class="SimpleMath">(n)</span> calls them <code class="code">"A"</code> and <code class="code">"B"</code>. So, our <strong class="pkg">GAP</strong> representation of the ball in Figure~\ref{fig:B3} is the following record:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ballAB(3);  </span>
rec( vertices := [ "A", "B" ], 
  faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ] ] ] 
 )
			</pre></div>

<p><a id="X81EA74AA7B4B6DDB" name="X81EA74AA7B4B6DDB"></a></p>

<h5>1.1-1 IsPolytope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPolytope</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Функция проверяет формальные признаки структуры <span class="SimpleMath">pol</span> в соответствии с правилами задания политопов. Если данные построенны корректным образом, то функция выдаст <span class="SimpleMath">true</span> и <span class="SimpleMath">false</span> в противном случае.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPolytope(T2);</span>
true
				</pre></div>

<p>Так как нет единого алгоритма распознавания <span class="SimpleMath">n-</span>мерной сферы, проверка того, что каждая клетка является шаром опушена. Это может породить ошибку когда данные удовлетворяют всем формальным признакам, но политоп не является шаровым. В данном случае программа, все равно выдаст <span class="SimpleMath">true</span> вместо положенноего <span class="SimpleMath">false.</span></p>

<p><a id="X7DC1CA798242AF10" name="X7DC1CA798242AF10"></a></p>

<h4>1.2 <span class="Heading">Укзывающие функции</span></h4>

<p>В данном разделе представлены функции которые могут либо разпознать многообразие по политопу, либо вычислить инвариант этого многообразия.</p>

<p><a id="X7E2C717A7CE81114" name="X7E2C717A7CE81114"></a></p>

<h5>1.2-1 FundGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FundGroup</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Computes the fundamental group of the given polytope.</p>

<p><a id="X815EDAEB7BDC2E6F" name="X815EDAEB7BDC2E6F"></a></p>

<h4>1.3 <span class="Heading">Общая информация о шаровом комлпексе</span></h4>

<p><a id="X7826D40B82C44A08" name="X7826D40B82C44A08"></a></p>

<h5>1.3-1 PolBoundary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolBoundary</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>вычисляет границу политопа. На выход подает список в котором указаны только клетки размерности <span class="SimpleMath">n-1</span> составляющие границу.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolBoundary(T2);</span>
[ ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:=sphereAB(1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d2:=ballAB(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ft2:=PolProduct(d2,s1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolBoundary(ft2);</span>
[ 1, 2, 3, 4 ]
						</pre></div>

<p>В данном примере <span class="SimpleMath">T2</span> является тором, <span class="SimpleMath">s1</span> - одномерная сфера, <span class="SimpleMath">d2</span> - двумерный диск и <span class="SimpleMath">ft2</span> - полнторие созданное как декартово произведение 2-диска и 1-сферы.</p>

<p><a id="X7DF0C625871788B7" name="X7DF0C625871788B7"></a></p>

<h5>1.3-2 PolInnerFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolInnerFaces</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Build index of inner faces of given polytope complex <span class="SimpleMath">returned[i]</span> - set of inner faces of dimensions (i-1). Any face is outer if it has at most 1 adjacent face of higher dimension of if it lies in the boundary of such a face. And inner faces are not outer faces.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolInnerFaces(T2);</span>
[ [ 1 .. 4 ], [ 1 .. 8 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolInnerFaces(ft2);</span>
[ [  ], [  ], [ 5, 6 ] ]
						</pre></div>

<p><a id="X7DDF02FE8581EF3D" name="X7DDF02FE8581EF3D"></a></p>

<h5>1.3-3 MaxTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MaxTree</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>finds a maximal tree in the 1-skeleton of a polytope as a list of edges.</p>

<p><a id="X82CF2896859B26C6" name="X82CF2896859B26C6"></a></p>

<h5>1.3-4 CellOrient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CellOrient</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Provides inductively some orientations for cells of dimensions <span class="SimpleMath">1..n=dim(pol)</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3:=sphereAB(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CellOrient(s3);</span>
[ [ [ -1, 1 ], [ -1, 1 ] ], [ [ -1, 1 ], [ -1, 1 ] ], [ [ -1, 1 ], [ -1, 1 ] ] ]
						</pre></div>

<p><a id="X7A1EAA26847A1C43" name="X7A1EAA26847A1C43"></a></p>

<h5>1.3-5 PolOrient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolOrient</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>If <span class="SimpleMath">pol</span> is orientable, gives a consistent orientation of <span class="SimpleMath">n-</span>faces (<span class="SimpleMath">n=dim(pol)</span>), otherwise returns <span class="SimpleMath">fail.</span></p>

<p><a id="X81AE197083B0A56A" name="X81AE197083B0A56A"></a></p>

<h5>1.3-6 OrientTriangulated</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrientTriangulated</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Function computes consistent orientation on simpleces of greatest dimension on a given triangulated complex <span class="SimpleMath">pol.</span> Returns array of -1, 1-s which correspond to the orientation of simplices of greatest dimension of <span class="SimpleMath">pol.</span></p>

<p><a id="X83986ED47DDF8E20" name="X83986ED47DDF8E20"></a></p>

<h5>1.3-7 dataPachner</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; dataPachner</code>( <var class="Arg">dim</var>, <var class="Arg">k</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Выводит информацию о указанном движении Пахнера размерности <span class="SimpleMath">dim</span>, один из класстеров которого содержит <span class="SimpleMath">k</span> - симплексов, все информация пренадлежащая данному кластеру условно обозначена буквой <span class="SimpleMath">l</span> (left). Второй кластер симплексов получающийся при преобразованиях Пахнера обозначен буквой <span class="SimpleMath">r</span> (right).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(dataPachner(3,2));</span>
rec(
  l := rec(
      pol := rec(
          faces :=
           [
              [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ],
                  [ 1, 5 ], [ 2, 5 ], [ 3, 5 ] ],
              [ [ 1, 4, 5 ], [ 1, 7, 8 ], [ 2, 4, 6 ], [ 2, 7, 9 ],
                  [ 3, 5, 6 ], [ 3, 8, 9 ], [ 1, 2, 3 ] ],
              [ [ 1, 3, 5, 7 ], [ 2, 4, 6, 7 ] ] ],
          vertices := [ 1, 2, 3, 4, 5 ] ),
      sim := [ [ 1, 2, 3, 4 ], [ 1, 2, 3, 5 ] ],
      vnut := [ 7 ] ),
  r := rec(
      pol := rec(
          faces :=
           [
              [ [ 1, 2 ], [ 1, 4 ], [ 2, 4 ], [ 1, 5 ], [ 2, 5 ], [ 4, 5 ],
                  [ 1, 3 ], [ 3, 4 ], [ 3, 5 ], [ 2, 3 ] ],
              [ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 2, 7, 8 ], [ 4, 7, 9 ],
                  [ 3, 8, 10 ], [ 5, 9, 10 ], [ 2, 4, 6 ], [ 3, 5, 6 ],
                  [ 6, 8, 9 ] ],
              [ [ 1, 2, 7, 8 ], [ 3, 4, 7, 9 ], [ 5, 6, 8, 9 ] ] ],
          vertices := [ 1, 2, 3, 4, 5 ] ),
      sim := [ [ 1, 2, 4, 5 ], [ 1, 3, 4, 5 ], [ 2, 3, 4, 5 ] ],
      vnut := [ 7, 8, 9 ] ) )
  						</pre></div>

<p>В каждой из этих двух записей <span class="SimpleMath">.l</span> или <span class="SimpleMath">.r</span> содержится <span class="SimpleMath">.pol</span> - задание кластера в виде шарового комплекса, <span class="SimpleMath">.sim</span> - представление кластера в виде симплексов, то есть задание симплексов через набор вершин на которые они натянуты и <span class="SimpleMath">.vnut</span> список внутренних <span class="SimpleMath">(n-1)-</span>мерных клеток шарового комплекса.</p>

<p>Симплциальный комплекс может быть задан как набор симплексов, каждый из которых представлен списком вершин на которые он натянут. При задании симплициальных многообразий достаточно указать симплексы размерности <span class="SimpleMath">n.</span> При этом существенным условием является то, что все симплексы должны быть натянуты на различные наборы вершин. Например граница четырехмерного симплекса может быть представлена как</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sim:=[ [ 1, 2, 3, 4 ], [ 1, 2, 3, 5 ], [ 1, 2, 4, 5 ],</span>
				[ 1, 3, 4, 5 ], [ 2, 3, 4, 5 ] ];
				</pre></div>

<p><a id="X873915C482448F75" name="X873915C482448F75"></a></p>

<h5>1.3-8 FromSimplexToPolytope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FromSimplexToPolytope</code>( <var class="Arg">simplex</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>преобразует список симплексов в шаровой комплекс.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FromSimplexToPolytope(sim);</span>
rec(
  faces :=
    [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ], [ 1, 5 ],
          [ 2, 5 ], [ 3, 5 ], [ 4, 5 ] ],
      [ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 2, 4, 6 ], [ 3, 5, 6 ], [ 1, 7, 8 ],
          [ 2, 7, 9 ], [ 3, 8, 9 ], [ 4, 7, 10 ], [ 5, 8, 10 ], [ 6, 9, 10 ] ]
        , [ [ 1, 2, 3, 4 ], [ 1, 5, 6, 7 ], [ 2, 5, 8, 9 ], [ 3, 6, 8, 10 ],
          [ 4, 7, 9, 10 ] ] ], vertices := [ 1, 2, 3, 4, 5 ] )
						</pre></div>

<p><a id="X860B263684CFACF7" name="X860B263684CFACF7"></a></p>

<h4>1.4 <span class="Heading">Работа с клетками</span></h4>

<p>В данном разделе собранны все функции позволяющие узнать информацию связанную с какой-либо клеткой в pl-разбиении многообарзия. Клетка в pl-многообразии указывается как пара чисел [dim,ind], первое из которых dim есть размерность клетки, второе ind - позиция клетки в списке pol.faces[dim].</p>

<p><a id="X7AB8BF4E7E72C22D" name="X7AB8BF4E7E72C22D"></a></p>

<h5>1.4-1 PolBnd</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolBnd</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Creating an index of boundary faces of face <span class="SimpleMath">adr=[dim,ind]</span> of complex <span class="SimpleMath">pol</span>. <span class="SimpleMath">result[i]</span> - index of (i-1)-dimensional faces of <span class="SimpleMath">pol</span> which are in the boundary of <span class="SimpleMath">adr</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolBnd(T2,[2,3]);</span>
[ [ 1, 2, 3, 4 ], [ 2, 4, 5, 7 ] ]
						</pre></div>

<p><a id="X7B4C20C784524379" name="X7B4C20C784524379"></a></p>

<h5>1.4-2 FaceComp</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FaceComp</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>функция аналогичная функции <span class="SimpleMath">PolBnd,</span> выходные данные в функции собраны по размерностям. <span class="SimpleMath">adr</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceComp(T2,[2,3]);</span>
rec( 0 := [ 1, 2, 3, 4 ], 1 := [ 2, 4, 5, 7 ], 2 := [ 3 ] )
						</pre></div>

<p>Как видно на выходе данные сгруппированы так же как и в функции <span class="SimpleMath">StarFace</span></p>

<p><a id="X7E4697E984788243" name="X7E4697E984788243"></a></p>

<h5>1.4-3 StarFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StarFace</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Вычисляет все клетки которые содержат клетку <span class="SimpleMath">adr</span> в политопе <span class="SimpleMath">pol</span>. Другими словами функция вычисляет звезду указанной клетки. result.(i) содержит индексы <span class="SimpleMath">i-</span>клеток входящих в состав звезды.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StarFace(T2,[0,3]);</span>
rec( 1 := [ 2, 3, 6, 7 ], 2 := [ 1, 2, 3, 4 ] )
						</pre></div>

<p>В данном примере 1-клетки с индексами 2, 3, 6 и 7 и 2-клетки с индексами 1, 2, 3 и 4 образуют звезду вершины 3 данного шарового разбиения.</p>

<p><a id="X7BBC530C857D247E" name="X7BBC530C857D247E"></a></p>

<h5>1.4-4 PolCheckComb</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolCheckComb</code>( <var class="Arg">pol</var>, <var class="Arg">dim</var>, <var class="Arg">pos</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>check if a face of given complex is combinatorial complex that is, whether every its subface of lower dimension is uniquely determined by its vertices (and dimension)</p>

<p><a id="X79A0EF12877971D1" name="X79A0EF12877971D1"></a></p>

<h4>1.5 <span class="Heading">Изменение <span class="SimpleMath">pl-</span>разбиения (не изменющие)</span></h4>

<p>Функции которые изменяют представленной разбиение без изменения многообразия собраны в этом разделе.</p>

<p><a id="X79EBAEC68713D5FE" name="X79EBAEC68713D5FE"></a></p>

<h5>1.5-1 PolTriangulate</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolTriangulate</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>функция содает триангуляцию политопа <span class="SimpleMath">pol</span>. Заметим, что политоп после треангуляции может остаться не комбинаторным.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolTriangulate(sphereAB(2));</span>
rec(
  faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ] ],
      [ [ 1, 3, 4 ], [ 2, 3, 4 ], [ 1, 5, 6 ], [ 2, 5, 6 ] ] ],
  vertices := [ "A", "B", "V1", "V2" ] )
</pre></div>

<p>Triangulating a polytope.</p>

<p><a id="X7DE97F0184E8F0BE" name="X7DE97F0184E8F0BE"></a></p>

<h5>1.5-2 FirstBoundary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FirstBoundary</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>данная функция создает такое упорядочение клеток политопа, что клетки лежащие на границе имеют наименьшие индексы в списках pol.faces[dim].</p>

<p><a id="X863CAD14822179DC" name="X863CAD14822179DC"></a></p>

<h5>1.5-3 PermFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermFaces</code>( <var class="Arg">pol</var>, <var class="Arg">perm</var>, <var class="Arg">dim</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>производит переупорядочение клеток размерности <span class="SimpleMath">dim</span> в политопе <span class="SimpleMath">pol</span> по перестановке <span class="SimpleMath">perm.</span></p>

<p>Клетку размерности <span class="SimpleMath">d</span> в шаровом комплексе называем минимальной, если ее граница содержит только две клетки размерности <span class="SimpleMath">d - 1</span></p>

<p><a id="X844FBAF17BC1B42B" name="X844FBAF17BC1B42B"></a></p>

<h5>1.5-4 ContractMiniFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ContractMiniFace</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>в политопе <span class="SimpleMath">pol</span> стягивается минимальная клетка <span class="SimpleMath">adr.</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:=sphereTriangul(1);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ] ], vertices := [ 1 .. 3 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:=ContractMiniFace(s1,[1,1]);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ 1, 3 ] )
</pre></div>

<p>В некоторых случаях стягивание минимальной клетки невозможно, так как данные которые мы получим после стягивания могут не оказаться <span class="SimpleMath">pl-</span>комплексом. Программа проведет стягиваение минимальной клетки в любом случае, даже если это запрещено. По этому, применение этой функции требует доказательства того, что после стягивание не нарушится условие, что все клетки полчившегося комплекса шары. Например, если в примере описанном выше попоробовать стянуть в окружности <span class="SimpleMath">s1</span> ребро, то получим следующее</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:=ContractMiniFace(s1,[1,1]);</span>
rec( faces := [ [ [ 1 ] ] ], vertices := [ 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPolytope(s1);</span>
false
</pre></div>

<p>Как видим выходные данные не являются политопом. По этому проверка возможности проведения этой операции остается за пользователем.</p>

<p><a id="X7AF2A3E286F2E10F" name="X7AF2A3E286F2E10F"></a></p>

<h5>1.5-5 DivideFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DivideFace</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var>, <var class="Arg">set</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>пусть имеется клетка с адресом <span class="SimpleMath">adr</span> размерности <span class="SimpleMath">d=adr[1]</span> и клетки <span class="SimpleMath">set</span> лежащие на гаранице клетки <span class="SimpleMath">adr</span> образуют <span class="SimpleMath">(d-2)-</span>мерную сферу, тогда клетку <span class="SimpleMath">adr</span> можно разбить на две части натянув на <span class="SimpleMath">(d-2)-</span>мерную сферу диск.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">octahedron:=rec(vertices:=[1..6], faces:=[</span>
		[	[ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 1, 4 ], [ 1, 5 ], [ 2, 5 ],
			[ 3, 5 ], [ 4, 5 ], [ 1, 6 ], [ 2, 6 ], [ 3, 6 ], [ 4, 6 ] ],

						</pre></div>

<p>В случае когда разбивается одномерная клетка разбиение проводится однозначно --- клетка дробится на две части новой вершиной, вместо множества <span class="SimpleMath">set</span> указывается имя новой вершины разбиения.</p>


<div class="example"><pre>
						 TODO привести пример с добавлением вершины 
						</pre></div>

<p><a id="X863829C97B6FAAA0" name="X863829C97B6FAAA0"></a></p>

<h5>1.5-6 PolSimplify1</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolSimplify1</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>По возможности проводит упрощение разбиения объединяя соседние клетки, производя обратную операцию к функции <span class="SimpleMath">DivideFace.</span></p>


<div class="example"><pre>
						 TODO после исправелния ошибки привести пример с
						триангулированной двумерной сферой 
						</pre></div>

<p><a id="X7A0D373E78BB66A0" name="X7A0D373E78BB66A0"></a></p>

<h4>1.6 <span class="Heading">Непосредственное создание политопов</span></h4>

<p>Для создания <span class="SimpleMath">n-</span>мерного диска и сферы имеются стандартные функции включенные в библиотеку</p>

<p><a id="X83EC07DE83EC07DE" name="X83EC07DE83EC07DE"></a></p>

<h5>1.6-1 ballAB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ballAB</code>( <var class="Arg">dim</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>создает минимально возможное шаровое разбиение диска размерности <span class="SimpleMath">dim.</span></p>

<p><a id="X791C9DFE87250DEF" name="X791C9DFE87250DEF"></a></p>

<h5>1.6-2 sphereAB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; sphereAB</code>( <var class="Arg">dim</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>создает минимально возможное pl-разбиение сферы размерности <span class="SimpleMath">dim.</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sphereAB(3);</span>
rec(
  faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ],
      [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ "A", "B" ] )
						</pre></div>

<p>В библиотеку так же влючена функция создающая задание диска и сферы в виде триангуливаронных шаровых комплексов</p>

<p><a id="X82DB526A7F364516" name="X82DB526A7F364516"></a></p>

<h5>1.6-3 ballTriangul</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ballTriangul</code>( <var class="Arg">dim</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>создает симплекс размерности <span class="SimpleMath">dim</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ballTriangul(2);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ], [ [ 1 .. 3 ] ] ],
  vertices := [ 1 .. 3 ] )
						</pre></div>

<p><a id="X80EEACD2781E40F7" name="X80EEACD2781E40F7"></a></p>

<h5>1.6-4 sphereTriangul</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; sphereTriangul</code>( <var class="Arg">dim</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>триангулированная сфера создается как граница <span class="SimpleMath">(dim+1)-</span>мерного симплекса</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sphereTriangul(1);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ] ], vertices := [ 1 .. 3 ] )
						</pre></div>

<p><a id="X7CC221C778D0F16A" name="X7CC221C778D0F16A"></a></p>

<h4>1.7 <span class="Heading">Топологические операции</span></h4>

<p><a id="X833B125E832EA5F5" name="X833B125E832EA5F5"></a></p>

<h5>1.7-1 FreeUnionPol</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FreeUnionPol</code>( <var class="Arg">pol1</var>, <var class="Arg">pol2</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>свободное объединение политопов.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FreeUnionPol(s1,s1);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 3, 4 ], [ 3, 4 ] ] ],
  vertices := [ [ 1, "A" ], [ 1, "B" ], [ 2, "A" ], [ 2, "B" ] ] )
						</pre></div>

<p><a id="X827171907A7228C4" name="X827171907A7228C4"></a></p>

<h5>1.7-2 PolCylinder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolCylinder</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Maybe not needed in view of the existence of <span class="SimpleMath">PolProduct</span>, but anyhow: triangulates a polytope <span class="SimpleMath">pol</span> and creates a triangulated cylinder over it; in the list for faces of any dimensions (including vertices), first go to identical copies of triangulated <span class="SimpleMath">pol</span> - <span class="SimpleMath">pol x 0</span> and <span class="SimpleMath">pol x 1</span>. Also, <span class="SimpleMath">result.l[i+1]</span> is the number of i-faces in the triangulated <span class="SimpleMath">pol.</span></p>

<p><a id="X813B0AA1829E736E" name="X813B0AA1829E736E"></a></p>

<h5>1.7-3 PolDoubleCone</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolDoubleCone</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Make a double cone with vertices V1 and V2 over the given polytope <span class="SimpleMath">pol.</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolDoubleCone(s1);</span>
rec(
  faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ] ],
      [ [ 1, 3, 4 ], [ 2, 3, 4 ], [ 1, 5, 6 ], [ 2, 5, 6 ] ] ],
  vertices := [ "A", "B", "V1", "V2" ] )
						</pre></div>

<p><a id="X7A9E18837F637D8D" name="X7A9E18837F637D8D"></a></p>

<h5>1.7-4 PolProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolProduct</code>( <var class="Arg">pol1</var>, <var class="Arg">pol2</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>функция вычисляет декартово произведение двух шаровых комплексов pol1 и pol2. Декартово произведение для двух шаровых комплексов определяется как шаровой комплекс составленный из всевозможных шаров <span class="SimpleMath">D^s_i × D^t_j</span>, где <span class="SimpleMath">D^s_i</span> и <span class="SimpleMath">D^t_j</span> клетки комплексов <span class="SimpleMath">M</span> и <span class="SimpleMath">N</span>, соответственно. cartesian product of two polytopes.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolProduct(s1,s1);</span>
rec(
  faces :=
    [ [ [ 1, 2 ], [ 1, 2 ], [ 3, 4 ], [ 3, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ],
          [ 2, 4 ] ],
      [ [ 1, 3, 5, 6 ], [ 2, 4, 5, 6 ], [ 1, 3, 7, 8 ], [ 2, 4, 7, 8 ] ] ],
  vertices := [ [ "A", "A" ], [ "A", "B" ], [ "B", "A" ], [ "B", "B" ] ] )
						</pre></div>

<p><a id="X7F0929CD82A0CE28" name="X7F0929CD82A0CE28"></a></p>

<h5>1.7-5 ImageInPolProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImageInPolProduct</code>( <var class="Arg">pol1</var>, <var class="Arg">pol2</var>[, <var class="Arg">adr1</var>, <var class="Arg">adr2</var>] )</td><td class="tdright">( функция )</td></tr></table></div>
<p>вспомогательная функция для декартового произведения, вычисляет адрес клетки составленной как произведение клеткок <span class="SimpleMath">adr1</span> и <span class="SimpleMath">adr2</span> из политопов <span class="SimpleMath">pol1</span> и <span class="SimpleMath">pol2,</span> соответственно.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:=PolProduct(s1,s1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageInPolProduct(s1,s1,[[1,2],[1,1]]);</span>
[ 2, 3 ]
						</pre></div>

<p>В качестве входных данных функции могут поступить не только политопы pol1 и pol2, но и именованные списки по размерностям, каждой размерности k в котором сопоставлена мощность клеток размерности k. Данная возможность позволяет не вычислять эту информацию, при частом вызове функции для одного и тогоже декартового произведения.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ls1:=rec(0:=2, 1:=2);</span>
rec( 0 := 2, 1 := 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageInPolProduct(ls1,ls1,[[1,2],[1,1]]);</span>
[ 2, 3 ]
						</pre></div>

<p>Обратим внимание, что функция вычисляет клетку только в комплексе составленном функцией PolProduct. Если произошло какое-либо изменение комплекса, указанный адрес может оказаться не корректным.</p>

<p><a id="X7A32AE2D8733963A" name="X7A32AE2D8733963A"></a></p>

<h5>1.7-6 PolProductSyms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolProductSyms</code>(  )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Cartesian product of two polytopes with symmetries of multipliers transferred to it. First go the symmetries of the first multiplier, then - the second.</p>

<p><a id="X7B4164647D6C5EC6" name="X7B4164647D6C5EC6"></a></p>

<h5>1.7-7 PolProductSymsDict</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolProductSymsDict</code>(  )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Cartesian product of two polytopes with symmetries of multipliers transferred to it. First go the symmetries of the first multiplier, then - the second. Also returns the face dictionary.</p>

<p><a id="X7A3091A38613DA64" name="X7A3091A38613DA64"></a></p>

<h5>1.7-8 PolFactorInvolution</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolFactorInvolution</code>( <var class="Arg">pol</var>, <var class="Arg">invol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p><span class="SimpleMath">pol</span> is polytope with symmetries, <span class="SimpleMath">invol</span> is such a list of some of its symmetries (repetitions possible) that it is known that the product of symmetries in s is an involution returns the factored polytope.</p>

<p><a id="X7C78FB387A55C8AB" name="X7C78FB387A55C8AB"></a></p>

<h4>1.8 <span class="Heading">Основные принцыпы перестроек шаровых комплексов</span></h4>

<p>В данном разделе рассказывается об основхных принцыпах перестройки шаровых комплексов связанных с изменением индексации клеток. Изменение индексации клеток является одной из основных трудностей для быстрого и удобного построения программ. Во второй версии пакета <span class="SimpleMath">PL</span> мы пользовались следующим принцыпом.</p>

<p><a id="X7F4B33CD85588148" name="X7F4B33CD85588148"></a></p>

<h5>1.8-1 DelFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DelFace</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>клетка <span class="SimpleMath">adr</span> корректным образом исключается из политопа <span class="SimpleMath">pol.</span> После проведения данной операции корректность данных может быть нарушена.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pol:=DelFace(t2,[1,2]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPolytope(pol);</span>
false
					</pre></div>

<p>Функция содержит наиболее часто встречающийся код в функциях который позволяет корректно удалить все упоминания о данной клетке и подготовить данные для дальнейшей работы алгоритма.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Начало книги]</a>&nbsp;  <a href="chap0.html#contents">[Содержание]</a>&nbsp;  &nbsp;<a href="chap0.html">[Предыдущая глава]</a>&nbsp;  &nbsp;<a href="chap2.html">[Следующая глава]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Перейти к главе: </span><a href="chap0.html">Начало</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
