<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (PL-manual) - Глава 1: Шаровые комплексы.</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Перейти к главе: </span><a href="chap0.html">Начало</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Начало книги]</a>&nbsp;  <a href="chap0.html#contents">[Содержание]</a>&nbsp;  &nbsp;<a href="chap0.html">[Предыдущая глава]</a>&nbsp;  &nbsp;<a href="chap2.html">[Следующая глава]</a>&nbsp;  </div>

<p><a id="X83577E337970576A" name="X83577E337970576A"></a></p>
<div class="ChapSects"><a href="chap1.html#X83577E337970576A">1 <span class="Heading">Шаровые комплексы.</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7A57CB8E853465BB">1.1 <span class="Heading">Representation of a PL ball complex</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X81EA74AA7B4B6DDB">1.1-1 IsPolytope</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X8663A2DA7C5D0144">1.2 <span class="Heading">Указывающие функции</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7F2B23508384AD56">1.2-1 EulerNumber</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7E2C717A7CE81114">1.2-2 FundGroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7C31865383DD667E">1.3 <span class="Heading">Общая информация о шаровом комплексе</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X82674C6C7C537F9E">1.3-1 LengthPol</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7826D40B82C44A08">1.3-2 PolBoundary</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7DF0C625871788B7">1.3-3 PolInnerFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7DDF02FE8581EF3D">1.3-4 MaxTree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X82CF2896859B26C6">1.3-5 CellOrient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A1EAA26847A1C43">1.3-6 PolOrient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X81AE197083B0A56A">1.3-7 OrientTriangulated</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X83986ED47DDF8E20">1.3-8 dataPachner</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X873915C482448F75">1.3-9 FromSimplexToPolytope</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X860B263684CFACF7">1.4 <span class="Heading">Работа с клетками</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7AB8BF4E7E72C22D">1.4-1 PolBnd</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7B4C20C784524379">1.4-2 FaceComp</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7E4697E984788243">1.4-3 StarFace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7BBC530C857D247E">1.4-4 PolCheckComb</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X81B61AF078A1C75E">1.5 <span class="Heading">Изменение <span class="SimpleMath">pl-</span>разбиения (не изменяющие)</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X79EBAEC68713D5FE">1.5-1 PolTriangulate</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7DE97F0184E8F0BE">1.5-2 FirstBoundary</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X863CAD14822179DC">1.5-3 PermFaces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X844FBAF17BC1B42B">1.5-4 ContractMiniFace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7AF2A3E286F2E10F">1.5-5 DivideFace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X8508B54A7A8AC6CB">1.5-6 UnionFace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X784F04327D5BD9A8">1.5-7 PolSimplify</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7A0D373E78BB66A0">1.6 <span class="Heading">Непосредственное создание политопов</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X83EC07DE83EC07DE">1.6-1 ballAB</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X791C9DFE87250DEF">1.6-2 sphereAB</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X82DB526A7F364516">1.6-3 ballTriangul</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X80EEACD2781E40F7">1.6-4 sphereTriangul</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7CC221C778D0F16A">1.7 <span class="Heading">Топологические операции</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X833B125E832EA5F5">1.7-1 FreeUnionPol</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X813B0AA1829E736E">1.7-2 PolDoubleCone</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A9E18837F637D8D">1.7-3 PolProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7F0929CD82A0CE28">1.7-4 ImageInPolProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7C2DFBEA78356D9D">1.7-5 PreimageInPolProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A32AE2D8733963A">1.7-6 PolProductSyms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7B4164647D6C5EC6">1.7-7 PolProductSymsDict</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7A3091A38613DA64">1.7-8 PolFactorInvolution</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X79A6E71D85EB8624">1.8 <span class="Heading">Основные принципы перестроек шаровых комплексов</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7F4B33CD85588148">1.8-1 DelFace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X8371078A7CD87B96">1.8-2 wasDelFace</a></span>
</div></div>
</div>

<h3>1 <span class="Heading">Шаровые комплексы.</span></h3>

<p>Piecewise-linear, or simply PL, ball complexes are, at least at this moment, the central objects with which our package <span class="SimpleMath">PL</span> deals. First, a ball complex is, simply speaking, a kind of cell complex but such where all <em>closed</em> cells ( = balls) are <em>embedded</em>. In particular, their boundaries are genuine spheres, not crumpled/folded. The formal definition of <span class="SimpleMath">PL</span> ball complex reads: A PL ball complex is a pair <span class="SimpleMath">(X, U)</span>, where <span class="SimpleMath">X</span> is a compact Euclidean polyhedron and <span class="SimpleMath">U</span> is a covering of <span class="SimpleMath">X</span> by closed PL-balls such that the following axioms are satisfied:</p>


<ul>
<li><p>the relative interiors of balls from <span class="SimpleMath">U</span> form a partition of <span class="SimpleMath">X</span>,</p>

</li>
<li><p>the boundary of each ball from <span class="SimpleMath">U</span> is a union of balls from <span class="SimpleMath">U</span>.</p>

</li>
</ul>
<p>We also call PL ball complexes ``polytopes'', for brevity, hence prefix ``Pol'' in the names of some of our functions.</p>

<p><a id="X7A57CB8E853465BB" name="X7A57CB8E853465BB"></a></p>

<h4>1.1 <span class="Heading">Representation of a PL ball complex</span></h4>

<p>A <span class="SimpleMath">PL</span>-ball complex is defined up to <span class="SimpleMath">PL</span>-homeomorphism only by the combinatorics of adjunctions of its balls. Due to this, we represent them combinatorially in the following way. First, we assume that all vertices in the complex are numbered from 1 to their total number <span class="SimpleMath">N_0</span>. Hence, in this sense, the 0-skeleton of the complex is described. Next, assuming that the <span class="SimpleMath">k</span>-skeleton is already given, which implies (in particular) the numeration of all <span class="SimpleMath">k</span>-cells, we describe the <span class="SimpleMath">(k+1)</span>-skeleton as the list of all <span class="SimpleMath">(k+1)</span>-cells, each of which, in its turn, is the set of numbers of <span class="SimpleMath">k</span>-cells in its boundary. Then we compose the list of length <span class="SimpleMath">n</span>, where <span class="SimpleMath">n</span> is the dimension of the complex, whose elements are lists of 1-,..., <span class="SimpleMath">n</span>-cells. Thus, a three-dimensional ball <span class="SimpleMath">B^3</span> can be represented by the following <span class="SimpleMath">PL</span> ball complex with two vertices 1 and 2:</p>


<div class="example"><pre>
[
  [ [1,2], [1,2] ], # two one-dimensional simplexes, each with
                    # ends 1 and 2, of which the first is referred to
                    # in the next line as 1, the second - as 2;
  [ [1,2], [1,2] ], # two disks - bigons - bounded each by
                    # one-dimensional simplexes 1 and 2;
  [ [1,2] ]         # the three-ball bounded by bigons 1 and 2
]
			</pre></div>

<p>ТУТ БЫ НАДО ВСТАВИТЬ КАРТИНКУ Actually, we add a list of vertices with their names or something like that in the beginning of the above ball complex representation. For instance, our function <code class="code">ballAB</code><span class="SimpleMath">(n)</span> calls them <code class="code">"A"</code> and <code class="code">"B"</code>. So, our <strong class="pkg">GAP</strong> representation of the ball in Figure~\ref{fig:B3} is the following record:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ballAB(3);  </span>
rec( vertices := [ "A", "B" ], 
  faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ] ] ] 
 )
			</pre></div>

<p><a id="X81EA74AA7B4B6DDB" name="X81EA74AA7B4B6DDB"></a></p>

<h5>1.1-1 IsPolytope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPolytope</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Функция проверяет формальные признаки структуры <span class="SimpleMath">pol</span> в соответствии с правилами задания политопов. Если данные построены корректным образом, то функция выдаст <span class="SimpleMath">true</span> и <span class="SimpleMath">false</span> в противном случае.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPolytope(T2);</span>
true
				</pre></div>

<p>Так как нет единого алгоритма распознавания <span class="SimpleMath">n-</span>мерной сферы, проверка того, что каждая клетка является шаром опушена. Это может породить ошибку когда данные удовлетворяют всем формальным признакам, но политоп не является шаровым. В данном случае программа, все равно выдаст <span class="SimpleMath">true</span> вместо положенного <span class="SimpleMath">false.</span></p>

<p><a id="X8663A2DA7C5D0144" name="X8663A2DA7C5D0144"></a></p>

<h4>1.2 <span class="Heading">Указывающие функции</span></h4>

<p>В данном разделе представлены функции которые могут либо распознать многообразие по политопу, либо вычислить инвариант этого многообразия.</p>

<p><a id="X7F2B23508384AD56" name="X7F2B23508384AD56"></a></p>

<h5>1.2-1 EulerNumber</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EulerNumber</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>функция вычисляет число Эйлера для шарового комплекса. Данная функция полиморфна и способна принимать для вычислений данные типа политоп (IsPolytope), именнованные списки по размерностям в котором содержится структура политопа и именованный список по размерностям элементами которого могут выступать количества клеток определенной размерности.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EulerNumber(T2);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EulerNumber(sphereAB(4));</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EulerNumber(sphereAB(3));</span>
0
					</pre></div>

<p><a id="X7E2C717A7CE81114" name="X7E2C717A7CE81114"></a></p>

<h5>1.2-2 FundGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FundGroup</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Computes the fundamental group of the given polytope.</p>

<p><a id="X7C31865383DD667E" name="X7C31865383DD667E"></a></p>

<h4>1.3 <span class="Heading">Общая информация о шаровом комплексе</span></h4>

<p><a id="X82674C6C7C537F9E" name="X82674C6C7C537F9E"></a></p>

<h5>1.3-1 LengthPol</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LengthPol</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>В <span class="SimpleMath">resul.d</span> указывается мощьность <span class="SimpleMath">d</span>-мерного остова в политопе <span class="SimpleMath">pol.</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LengthPol(T2);</span>
total16
rec( 0 := 4, 1 := 8, 2 := 4 )
  	</pre></div>

<p><a id="X7826D40B82C44A08" name="X7826D40B82C44A08"></a></p>

<h5>1.3-2 PolBoundary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolBoundary</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>вычисляет границу политопа. На выход подает список в котором указаны только клетки размерности <span class="SimpleMath">(n-1)</span> составляющие границу.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolBoundary(T2);</span>
[ ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:=sphereAB(1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d2:=ballAB(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ft2:=PolProduct(d2,s1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolBoundary(ft2);</span>
[ 1, 2, 3, 4 ]
						</pre></div>

<p>В данном примере <span class="SimpleMath">T2</span> является тором, <span class="SimpleMath">s1</span> - одномерная сфера, <span class="SimpleMath">d2</span> - двумерный диск и <span class="SimpleMath">ft2</span> - полноторие созданное как декартово произведение 2-диска и 1-сферы.</p>

<p><a id="X7DF0C625871788B7" name="X7DF0C625871788B7"></a></p>

<h5>1.3-3 PolInnerFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolInnerFaces</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Build index of inner faces of given polytope complex <span class="SimpleMath">returned[i]</span> - set of inner faces of dimensions (i-1). Any face is outer if it has at most 1 adjacent face of higher dimension of if it lies in the boundary of such a face. And inner faces are not outer faces.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolInnerFaces(T2);</span>
[ [ 1 .. 4 ], [ 1 .. 8 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolInnerFaces(ft2);</span>
[ [  ], [  ], [ 5, 6 ] ]
						</pre></div>

<p><a id="X7DDF02FE8581EF3D" name="X7DDF02FE8581EF3D"></a></p>

<h5>1.3-4 MaxTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MaxTree</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>finds a maximal tree in the 1-skeleton of a polytope as a list of edges.</p>

<p><a id="X82CF2896859B26C6" name="X82CF2896859B26C6"></a></p>

<h5>1.3-5 CellOrient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CellOrient</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Provides inductively some orientations for cells of dimensions <span class="SimpleMath">1..n=dim(pol)</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3:=sphereAB(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CellOrient(s3);</span>
[ [ [ -1, 1 ], [ -1, 1 ] ], [ [ -1, 1 ], [ -1, 1 ] ], [ [ -1, 1 ], [ -1, 1 ] ] ]
						</pre></div>

<p><a id="X7A1EAA26847A1C43" name="X7A1EAA26847A1C43"></a></p>

<h5>1.3-6 PolOrient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolOrient</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>If <span class="SimpleMath">pol</span> is orientable, gives a consistent orientation of <span class="SimpleMath">n-</span>faces (<span class="SimpleMath">n=dim(pol)</span>), otherwise returns <span class="SimpleMath">fail.</span></p>

<p><a id="X81AE197083B0A56A" name="X81AE197083B0A56A"></a></p>

<h5>1.3-7 OrientTriangulated</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrientTriangulated</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Function computes consistent orientation on simpleces of greatest dimension on a given triangulated complex <span class="SimpleMath">pol.</span> Returns array of -1, 1-s which correspond to the orientation of simplices of greatest dimension of <span class="SimpleMath">pol.</span></p>

<p><a id="X83986ED47DDF8E20" name="X83986ED47DDF8E20"></a></p>

<h5>1.3-8 dataPachner</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; dataPachner</code>( <var class="Arg">dim</var>, <var class="Arg">k</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Выводит информацию о указанном движении Пахнера размерности <span class="SimpleMath">dim</span>, один из кластеров которого содержит <span class="SimpleMath">k</span> - симплексов, все информация принадлежащая данному кластеру условно обозначена буквой <span class="SimpleMath">l</span> (left). Второй кластер симплексов получающийся при преобразованиях Пахнера обозначен буквой <span class="SimpleMath">r</span> (right).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(dataPachner(3,2));</span>
rec(
  l := rec(
      pol := rec(
          faces :=
           [
              [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ],
                  [ 1, 5 ], [ 2, 5 ], [ 3, 5 ] ],
              [ [ 1, 4, 5 ], [ 1, 7, 8 ], [ 2, 4, 6 ], [ 2, 7, 9 ],
                  [ 3, 5, 6 ], [ 3, 8, 9 ], [ 1, 2, 3 ] ],
              [ [ 1, 3, 5, 7 ], [ 2, 4, 6, 7 ] ] ],
          vertices := [ 1, 2, 3, 4, 5 ] ),
      sim := [ [ 1, 2, 3, 4 ], [ 1, 2, 3, 5 ] ],
      vnut := [ 7 ] ),
  r := rec(
      pol := rec(
          faces :=
           [
              [ [ 1, 2 ], [ 1, 4 ], [ 2, 4 ], [ 1, 5 ], [ 2, 5 ], [ 4, 5 ],
                  [ 1, 3 ], [ 3, 4 ], [ 3, 5 ], [ 2, 3 ] ],
              [ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 2, 7, 8 ], [ 4, 7, 9 ],
                  [ 3, 8, 10 ], [ 5, 9, 10 ], [ 2, 4, 6 ], [ 3, 5, 6 ],
                  [ 6, 8, 9 ] ],
              [ [ 1, 2, 7, 8 ], [ 3, 4, 7, 9 ], [ 5, 6, 8, 9 ] ] ],
          vertices := [ 1, 2, 3, 4, 5 ] ),
      sim := [ [ 1, 2, 4, 5 ], [ 1, 3, 4, 5 ], [ 2, 3, 4, 5 ] ],
      vnut := [ 7, 8, 9 ] ) )
  						</pre></div>

<p>В каждой из этих двух записей <span class="SimpleMath">.l</span> или <span class="SimpleMath">.r</span> содержатся структуры <span class="SimpleMath">.pol</span> - задание кластера в виде шарового комплекса, <span class="SimpleMath">.sim</span> - представление кластера в виде симплексов, то есть задание симплексов через набор вершин на которые они натянуты и <span class="SimpleMath">.vnut</span> список внутренних <span class="SimpleMath">(n-1)-</span>мерных клеток шарового комплекса.</p>

<p>Симплициальный комплекс может быть задан как набор симплексов, каждый из которых представлен списком вершин на которые он натянут. При задании симплициальных многообразий достаточно указать симплексы размерности <span class="SimpleMath">n.</span> При этом существенным условием является то, что все симплексы должны быть натянуты на различные наборы вершин. Например граница четырехмерного симплекса может быть представлена как</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sim:=[ [ 1, 2, 3, 4 ], [ 1, 2, 3, 5 ], [ 1, 2, 4, 5 ],</span>
				[ 1, 3, 4, 5 ], [ 2, 3, 4, 5 ] ];
				</pre></div>

<p><a id="X873915C482448F75" name="X873915C482448F75"></a></p>

<h5>1.3-9 FromSimplexToPolytope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FromSimplexToPolytope</code>( <var class="Arg">simplex</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>преобразует список симплексов в шаровой комплекс.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FromSimplexToPolytope(sim);</span>
rec(
  faces :=
    [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ], [ 1, 5 ],
          [ 2, 5 ], [ 3, 5 ], [ 4, 5 ] ],
      [ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 2, 4, 6 ], [ 3, 5, 6 ], [ 1, 7, 8 ],
          [ 2, 7, 9 ], [ 3, 8, 9 ], [ 4, 7, 10 ], [ 5, 8, 10 ], [ 6, 9, 10 ] ]
        , [ [ 1, 2, 3, 4 ], [ 1, 5, 6, 7 ], [ 2, 5, 8, 9 ], [ 3, 6, 8, 10 ],
          [ 4, 7, 9, 10 ] ] ], vertices := [ 1, 2, 3, 4, 5 ] )
						</pre></div>

<p><a id="X860B263684CFACF7" name="X860B263684CFACF7"></a></p>

<h4>1.4 <span class="Heading">Работа с клетками</span></h4>

<p>В данном разделе собраны все функции позволяющие узнать информацию связанную с какой-либо клеткой в pl-разбиении многообразия. Клетка в pl-многообразии указывается как пара чисел [dim,ind], первое из которых dim есть размерность клетки, второе ind - позиция клетки в списке pol.faces[dim]. Такую пару в описании программ мы будет называть адресом клетки или клеткой, обозначение <span class="SimpleMath">adr.</span></p>

<p><a id="X7AB8BF4E7E72C22D" name="X7AB8BF4E7E72C22D"></a></p>

<h5>1.4-1 PolBnd</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolBnd</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Creating an index of boundary faces of face <span class="SimpleMath">adr=[dim,ind]</span> of complex <span class="SimpleMath">pol</span>. <span class="SimpleMath">result[i]</span> - index of (i-1)-dimensional faces of <span class="SimpleMath">pol</span> which are in the boundary of <span class="SimpleMath">adr</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolBnd(T2,[2,3]);</span>
[ [ 1, 2, 3, 4 ], [ 2, 4, 5, 7 ] ]
						</pre></div>

<p><a id="X7B4C20C784524379" name="X7B4C20C784524379"></a></p>

<h5>1.4-2 FaceComp</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FaceComp</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>функция аналогичная функции <span class="SimpleMath">PolBnd,</span> выходные данные в функции собраны по размерностям. Сама клетка тоже включена в вывод как составляющая часть самой себя.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FaceComp(T2,[2,3]);</span>
rec( 0 := [ 1, 2, 3, 4 ], 1 := [ 2, 4, 5, 7 ], 2 := [ 3 ] )
						</pre></div>

<p>Как видно из примера каждая именованное поле соответствует некоторой размерности.</p>

<p><a id="X7E4697E984788243" name="X7E4697E984788243"></a></p>

<h5>1.4-3 StarFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StarFace</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Вычисляет все клетки которые содержат клетку <span class="SimpleMath">adr</span> в политопе <span class="SimpleMath">pol</span>. Другими словами функция вычисляет звезду указанной клетки. result.(i) содержит индексы <span class="SimpleMath">i-</span>клеток входящих в состав звезды.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StarFace(T2,[0,3]);</span>
rec( 1 := [ 2, 3, 6, 7 ], 2 := [ 1, 2, 3, 4 ] )
						</pre></div>

<p>В данном примере 1-клетки с индексами 2, 3, 6 и 7 и 2-клетки с индексами 1, 2, 3 и 4 образуют звезду вершины 3 данного шарового разбиения.</p>

<p><a id="X7BBC530C857D247E" name="X7BBC530C857D247E"></a></p>

<h5>1.4-4 PolCheckComb</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolCheckComb</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>check if a face of given complex is combinatorial complex that is, whether every its subface of lower dimension is uniquely determined by its vertices (and dimension)</p>

<p><a id="X81B61AF078A1C75E" name="X81B61AF078A1C75E"></a></p>

<h4>1.5 <span class="Heading">Изменение <span class="SimpleMath">pl-</span>разбиения (не изменяющие)</span></h4>

<p>Функции которые изменяют представленное разбиение без изменения многообразия.</p>

<p><a id="X79EBAEC68713D5FE" name="X79EBAEC68713D5FE"></a></p>

<h5>1.5-1 PolTriangulate</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolTriangulate</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>функция создает триангуляцию политопа <span class="SimpleMath">pol</span>. Заметим, что политоп после триангуляции может остаться не комбинаторным.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolTriangulate(sphereAB(2));</span>
rec(
  faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ] ],
      [ [ 1, 3, 4 ], [ 2, 3, 4 ], [ 1, 5, 6 ], [ 2, 5, 6 ] ] ],
  vertices := [ "A", "B", "V1", "V2" ] )
						</pre></div>

<p>Triangulating a polytope.</p>

<p><a id="X7DE97F0184E8F0BE" name="X7DE97F0184E8F0BE"></a></p>

<h5>1.5-2 FirstBoundary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FirstBoundary</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>данная функция создает такое упорядочение клеток политопа, что клетки лежащие на границе имеют наименьшие индексы в списках pol.faces[dim]. Внутренний порядок клеток на границе остается неизменным (имеется в виду порядок клеток созданный индексацией внутри политопа).</p>

<p><a id="X863CAD14822179DC" name="X863CAD14822179DC"></a></p>

<h5>1.5-3 PermFaces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermFaces</code>( <var class="Arg">pol</var>, <var class="Arg">perm</var>, <var class="Arg">dim</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>производит переупорядочение клеток размерности <span class="SimpleMath">dim</span> в политопе <span class="SimpleMath">pol</span> по перестановке <span class="SimpleMath">perm.</span></p>

<p>Клетку размерности <span class="SimpleMath">d</span> в шаровом комплексе называем минимальной, если ее граница содержит только две клетки размерности <span class="SimpleMath">(d - 1)</span></p>

<p><a id="X844FBAF17BC1B42B" name="X844FBAF17BC1B42B"></a></p>

<h5>1.5-4 ContractMiniFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ContractMiniFace</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>В политопе <span class="SimpleMath">pol</span> стягивается минимальная клетка <span class="SimpleMath">adr.</span> Образом стягивания при этом является граничная клетка с меньшим индексом.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:=sphereTriangul(1);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ] ], vertices := [ 1 .. 3 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:=ContractMiniFace(s1,[1,1]);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ 1, 3 ] )
						</pre></div>

<p>В некоторых случаях стягивание минимальной клетки невозможно, так как данные которые мы получим после стягивания могут не оказаться <span class="SimpleMath">pl-</span>комплексом. Программа проведет стягивание минимальной клетки в любом случае, даже если применение функции выведет нас из категории шаровых комплексов. По этому, применение этой функции требует доказательства того, что после стягивание не нарушится условие, что все клетки получившегося комплекса шары. Например, если в примере описанном выше попробовать стянуть в окружности <span class="SimpleMath">s1</span> ребро, то получим следующее</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:=ContractMiniFace(s1,[1,1]);</span>
rec( faces := [ [ [ 1 ] ] ], vertices := [ 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPolytope(s1);</span>
false
						</pre></div>

<p>Как видим выходные данные не являются политопом. По этому проверка допустимости данной операции остается за пользователем.</p>

<p><a id="X7AF2A3E286F2E10F" name="X7AF2A3E286F2E10F"></a></p>

<h5>1.5-5 DivideFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DivideFace</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var>, <var class="Arg">set</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Пусть имеется клетка с адресом <span class="SimpleMath">adr</span> размерности <span class="SimpleMath">d=adr[1]</span> и клетки <span class="SimpleMath">set</span> лежащие на границе клетки <span class="SimpleMath">adr</span> образуют <span class="SimpleMath">(d-2)-</span>мерную сферу <span class="SimpleMath">S^d-2</span>, тогда клетку <span class="SimpleMath">adr</span> можно разбить на две части натянув на сферу <span class="SimpleMath">S^d-2</span> диск <span class="SimpleMath">D^d-1</span> внутри клетки <span class="SimpleMath">adr</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">octahedron;</span>
rec(
  faces :=
	[ [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 1, 4 ], [ 1, 5 ], [ 2, 5 ], [ 3, 5 ], 
  		[ 4, 5 ], [ 1, 6 ], [ 2, 6 ], [ 3, 6 ], [ 4, 6 ] ],
	  [ [ 1, 5, 6 ], [ 2, 6, 7 ], [ 3, 7, 8 ], [ 4, 5, 8 ], [ 1, 9, 10 ],
	  	[ 2, 10, 11 ], [ 3, 11, 12 ], [ 4, 9, 12 ] ], [ [ 1 .. 8 ] ] ], 
	vertices := [ 1 .. 6 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DivideFace(octahedron,[3,1],[1,2,3,4]);</span>
rec(
  faces :=
 	[ [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 1, 4 ], [ 1, 5 ], [ 2, 5 ], [ 3, 5 ],
  		[ 4, 5 ], [ 1, 6 ], [ 2, 6 ], [ 3, 6 ], [ 4, 6 ] ],
	  [ [ 1, 5, 6 ], [ 2, 6, 7 ], [ 3, 7, 8 ], [ 4, 5, 8 ], [ 1, 9, 10 ], 
	    [ 2, 10, 11 ], [ 3, 11, 12 ], [ 4, 9, 12 ], [ 1, 2, 3, 4 ] ],
	  [ [ 1, 4, 2, 3, 9 ], [ 5, 6, 7, 8, 9 ] ] ], 
		vertices := [ 1 .. 6 ] )
						</pre></div>

<p>В случае когда разбивается одномерная клетка, указанная клетка дробится на две части новой вершиной, вместо множества <span class="SimpleMath">set</span> указывается имя новой вершины разбиения.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:=sphereAB(1);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ "A", "B" ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DivideFace(s1,[1,1],3);</span>
rec( faces := [ [ [ 1, 3 ], [ 1, 2 ], [ 2, 3 ] ] ], vertices := [ "A", "B", 3 ] )
						</pre></div>

<p><a id="X8508B54A7A8AC6CB" name="X8508B54A7A8AC6CB"></a></p>

<h5>1.5-6 UnionFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnionFace</code>( <var class="Arg">pol</var>, <var class="Arg">kl1</var>, <var class="Arg">kl2</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>на вход функции посылаются две клетки одной и той же размерности для объединения их в одну клетку. По сути данной функцией реализуется обратная операция к функции <span class="SimpleMath">DivideFace</span> разбивающей клетку на две части.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnionFace(p3,[3,1],[3,2]);</span>
rec(
  faces :=
    [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ], [ 1, 5 ],
          [ 2, 5 ], [ 3, 5 ], [ 4, 5 ] ],
      [ [ 2, 4, 6 ], [ 2, 7, 9 ], [ 4, 7, 10 ], [ 3, 5, 6 ], [ 3, 8, 9 ],
          [ 5, 8, 10 ], [ 1, 4, 5 ], [ 1, 7, 8 ] ],
      [ [ 1, 2, 4, 5, 7, 8 ], [ 3, 6, 7, 8 ] ] ],
  vertices := [ 1, 2, 3, 4, 5 ] )
		</pre></div>

<p>Объединение двух клеток <span class="SimpleMath">D^k_1</span> и <span class="SimpleMath">D^k_2</span> в одну в политопе <span class="SimpleMath">pol</span> можно провести только в том случае если звезда пересечения этих клеток состоит только из <span class="SimpleMath">D^k_1</span> и <span class="SimpleMath">D^k_2</span>. Для проведения объединения функция проверяет, что данные клетки пересекаются по одному диску. Если после объединения указанных клеток комплекс перестанет быть шаровым разбиением, то функция не будет проводить объединение, на выход будет подан начальный политоп и информационная строка с пояснением почему функция отказывается работать.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UnionFace(T2,[2,1],[2,3]);;</span>
This faces intersected on some balls or not intersected.
I cannot union the faces in a polytope.
  	</pre></div>

<p><a id="X784F04327D5BD9A8" name="X784F04327D5BD9A8"></a></p>

<h5>1.5-7 PolSimplify</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolSimplify</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>проводит упрощение политопа <span class="SimpleMath">pol</span> фукцией UnionFaces. Данная функция перебирает все возможности начиная с клеток максимальной размерности. Вновь появившиеся возможности функция не исследует. По этому функцию можно запускать несколько раз если целью стоит максимально упростить политоп.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a:=ballTriangul(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolSimplify(a);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ] ]
     ], vertices := [ 1, 2 ] )
  	</pre></div>

<p><a id="X7A0D373E78BB66A0" name="X7A0D373E78BB66A0"></a></p>

<h4>1.6 <span class="Heading">Непосредственное создание политопов</span></h4>

<p>Для создания <span class="SimpleMath">n-</span>мерного диска и сферы имеются стандартные функции включенные в библиотеку</p>

<p><a id="X83EC07DE83EC07DE" name="X83EC07DE83EC07DE"></a></p>

<h5>1.6-1 ballAB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ballAB</code>( <var class="Arg">dim</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Создает минимально возможное шаровое разбиение диска размерности <span class="SimpleMath">dim.</span></p>

<p><a id="X791C9DFE87250DEF" name="X791C9DFE87250DEF"></a></p>

<h5>1.6-2 sphereAB</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; sphereAB</code>( <var class="Arg">dim</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Создает минимально возможное pl-разбиение сферы размерности <span class="SimpleMath">dim.</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sphereAB(3);</span>
rec(
  faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ],
      [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ "A", "B" ] )
						</pre></div>

<p>В библиотеку так же включена функция создающая задание диска и сферы в виде триангулированных шаровых комплексов</p>

<p><a id="X82DB526A7F364516" name="X82DB526A7F364516"></a></p>

<h5>1.6-3 ballTriangul</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ballTriangul</code>( <var class="Arg">dim</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Создает симплекс размерности <span class="SimpleMath">dim</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ballTriangul(2);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ], [ [ 1 .. 3 ] ] ],
  vertices := [ 1 .. 3 ] )
						</pre></div>

<p><a id="X80EEACD2781E40F7" name="X80EEACD2781E40F7"></a></p>

<h5>1.6-4 sphereTriangul</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; sphereTriangul</code>( <var class="Arg">dim</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Триангулированная сфера создается как граница <span class="SimpleMath">(dim+1)-</span>мерного симплекса</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sphereTriangul(1);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ] ], vertices := [ 1 .. 3 ] )
						</pre></div>

<p><a id="X7CC221C778D0F16A" name="X7CC221C778D0F16A"></a></p>

<h4>1.7 <span class="Heading">Топологические операции</span></h4>

<p><a id="X833B125E832EA5F5" name="X833B125E832EA5F5"></a></p>

<h5>1.7-1 FreeUnionPol</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FreeUnionPol</code>( <var class="Arg">pol1</var>, <var class="Arg">pol2</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Свободное объединение политопов.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FreeUnionPol(s1,s1);</span>
rec( faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 3, 4 ], [ 3, 4 ] ] ],
  vertices := [ [ 1, "A" ], [ 1, "B" ], [ 2, "A" ], [ 2, "B" ] ] )
						</pre></div>

<p>Объединение происходит путем слияния соответствующих списков. При этом индексы второго политопа увеличиваются.</p>

<p><a id="X813B0AA1829E736E" name="X813B0AA1829E736E"></a></p>

<h5>1.7-2 PolDoubleCone</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolDoubleCone</code>( <var class="Arg">pol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Make a double cone with vertices V1 and V2 over the given polytope <span class="SimpleMath">pol.</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolDoubleCone(s1);</span>
rec(
  faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ] ],
      [ [ 1, 3, 4 ], [ 2, 3, 4 ], [ 1, 5, 6 ], [ 2, 5, 6 ] ] ],
  vertices := [ "A", "B", "V1", "V2" ] )
						</pre></div>

<p><a id="X7A9E18837F637D8D" name="X7A9E18837F637D8D"></a></p>

<h5>1.7-3 PolProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolProduct</code>( <var class="Arg">pol1</var>, <var class="Arg">pol2</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Функция вычисляет декартово произведение двух шаровых комплексов pol1 и pol2. Декартово произведение для двух шаровых комплексов определяется как шаровой комплекс составленный из всевозможных шаров <span class="SimpleMath">D^s_i × D^t_j</span>, где <span class="SimpleMath">D^s_i</span> и <span class="SimpleMath">D^t_j</span> клетки комплексов <span class="SimpleMath">M</span> и <span class="SimpleMath">N</span>, соответственно.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolProduct(s1,s1);</span>
rec(
  faces :=
    [ [ [ 1, 2 ], [ 1, 2 ], [ 3, 4 ], [ 3, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ],
          [ 2, 4 ] ],
      [ [ 1, 3, 5, 6 ], [ 2, 4, 5, 6 ], [ 1, 3, 7, 8 ], [ 2, 4, 7, 8 ] ] ],
  vertices := [ [ "A", "A" ], [ "A", "B" ], [ "B", "A" ], [ "B", "B" ] ] )
						</pre></div>

<p><a id="X7F0929CD82A0CE28" name="X7F0929CD82A0CE28"></a></p>

<h5>1.7-4 ImageInPolProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ImageInPolProduct</code>( <var class="Arg">pol1</var>, <var class="Arg">pol2</var>, <var class="Arg">kl1xkl2</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Вспомогательная функция для декартова произведения, вычисляет адрес клетки составленной как произведение клеток <span class="SimpleMath">kl1</span> и <span class="SimpleMath">kl2</span> из политопов <span class="SimpleMath">pol1</span> и <span class="SimpleMath">pol2,</span> соответственно. На вход функции адреса клеток подаются объединенные в список.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:=PolProduct(s1,s1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageInPolProduct(s1,s1,[[1,2],[1,1]]);</span>
[ 2, 3 ]
						</pre></div>

<p>В качестве входных данных функции могут поступить не только политопы pol1 и pol2, но и именованные списки по размерностям, каждой размерности k в котором сопоставлена мощность клеток размерности k. Данная возможность позволяет не вычислять эту информацию, при частом вызове функции для одного и того же декартова произведения.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ls1:=rec(0:=2, 1:=2);</span>
rec( 0 := 2, 1 := 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ImageInPolProduct(ls1,ls1,[[1,2],[1,1]]);</span>
[ 2, 3 ]
						</pre></div>

<p>Обратим внимание, что функция вычисляет клетку только в комплексе составленном функцией PolProduct. Если произошло какое-либо изменение комплекса, указанный адрес может оказаться не корректным.</p>

<p><a id="X7C2DFBEA78356D9D" name="X7C2DFBEA78356D9D"></a></p>

<h5>1.7-5 PreimageInPolProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreimageInPolProduct</code>( <var class="Arg">pol1</var>, <var class="Arg">pol2</var>, <var class="Arg">imageface</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>По заданному образу в декартовом произведении политопов pol1 и pol2 указываем из каких клеток была составлена данная клетка imageface.</p>

<p><a id="X7A32AE2D8733963A" name="X7A32AE2D8733963A"></a></p>

<h5>1.7-6 PolProductSyms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolProductSyms</code>(  )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Cartesian product of two polytopes with symmetries of multipliers transferred to it. First go the symmetries of the first multiplier, then - the second.</p>

<p><a id="X7B4164647D6C5EC6" name="X7B4164647D6C5EC6"></a></p>

<h5>1.7-7 PolProductSymsDict</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolProductSymsDict</code>(  )</td><td class="tdright">( функция )</td></tr></table></div>
<p>Cartesian product of two polytopes with symmetries of multipliers transferred to it. First go the symmetries of the first multiplier, then - the second. Also returns the face dictionary.</p>

<p><a id="X7A3091A38613DA64" name="X7A3091A38613DA64"></a></p>

<h5>1.7-8 PolFactorInvolution</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolFactorInvolution</code>( <var class="Arg">pol</var>, <var class="Arg">invol</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p><span class="SimpleMath">pol</span> is polytope with symmetries, <span class="SimpleMath">invol</span> is such a list of some of its symmetries (repetitions possible) that it is known that the product of symmetries in s is an involution returns the factored polytope.</p>

<p><a id="X79A6E71D85EB8624" name="X79A6E71D85EB8624"></a></p>

<h4>1.8 <span class="Heading">Основные принципы перестроек шаровых комплексов</span></h4>

<p>В данном разделе рассказывается об основных принципах перестройки шаровых комплексов связанных с изменением индексации клеток. Изменение индексации клеток является одной из основных трудностей для быстрого и удобного построения программ. Во второй версии пакета <span class="SimpleMath">PL</span> мы пользовались следующей идеей. По возможности адреса клеток которые не участвуют в операции должны остаться неизменными. Тем не менее это не всегда возможно, когда, например, клетка удаляется из политопа. Если не удается избежать смещение индексов, то по возможности необходимо сделать так, что бы индексы изменились у минимального количества индексов. Та особенность, что все построение политопа привязана к позиции соответствующих клеток в списках pol.faces[k] осложняет работу связанную с перестройкой комплексов. Начиная с третьей версии пакета <span class="SimpleMath">PL</span> будет организована возможность жесткой индексации клеток, когда позиция клетки в списке pol.faces[k] является одновременно и именем этой клетки. Это, например, будет означать, что в списках pol.faces[k] могут присутствовать пустые адреса. На данный момент присутствуют следующие функции позволяющие корректно изменять структуру политопа и прикрепленную к нему информацию.</p>

<p><a id="X7F4B33CD85588148" name="X7F4B33CD85588148"></a></p>

<h5>1.8-1 DelFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DelFace</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>клетка <span class="SimpleMath">adr</span> корректным образом исключается из политопа <span class="SimpleMath">pol.</span> После проведения данной операции корректность данных может быть нарушена.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pol:=DelFace(t2,[1,2]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPolytope(pol);</span>
false
					</pre></div>

<p>Функция содержит наиболее часто встречающийся код в функциях который позволяет корректно удалить все упоминания о данной клетке и подготовить данные для дальнейшей работы алгоритма.</p>

<p><a id="X8371078A7CD87B96" name="X8371078A7CD87B96"></a></p>

<h5>1.8-2 wasDelFace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; wasDelFace</code>( <var class="Arg">pol</var>, <var class="Arg">adr</var> )</td><td class="tdright">( функция )</td></tr></table></div>
<p>функция корректирует сопуствующую информацию прикрепленную к политопу <span class="SimpleMath">pol</span> которая должна была измениться после удаления одной из клеток. На вход функции подается политоп и адрес той клетки которая была удалена. Напомним, что после удаления клетки индексы больших клеток данной размерности понижаются на едининцу, это изменение индексации должно быть отображено в той информации которая сопутствует данному шаровому комплексу. Если из какой-либо сопуствующей информации была удалена клетка, то будет выведено соответствующее сообщение, но изменения будут проведены. При обработке информации по 2-узле в политопе будет, в случае если удаляется 2-клетка, будет выведено соответствующее сообщение, индекс 2-клетки будет удален из списка .2knot.sheets, если на данную 2-клетку есть ссылка в .2knot.dpoints.(1kl), то соответсвующая позиция будет очищена</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Начало книги]</a>&nbsp;  <a href="chap0.html#contents">[Содержание]</a>&nbsp;  &nbsp;<a href="chap0.html">[Предыдущая глава]</a>&nbsp;  &nbsp;<a href="chap2.html">[Следующая глава]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Перейти к главе: </span><a href="chap0.html">Начало</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
